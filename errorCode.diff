diff --git a/dm/include/display_manager_adapter.h b/dm/include/display_manager_adapter.h
index 8e136bcb..6d173e8a 100644
--- a/dm/include/display_manager_adapter.h
+++ b/dm/include/display_manager_adapter.h
@@ -30,9 +30,9 @@
 namespace OHOS::Rosen {
 class BaseAdapter {
 public:
-    virtual bool RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    virtual DMError RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type);
-    virtual bool UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    virtual DMError UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type);
     virtual void Clear();
 protected:
@@ -82,17 +82,17 @@ public:
     virtual DMError SetVirtualScreenSurface(ScreenId screenId, sptr<Surface> surface);
     virtual bool SetScreenPowerForAll(ScreenPowerState state, PowerStateChangeReason reason);
     virtual ScreenPowerState GetScreenPower(ScreenId dmsScreenId);
-    virtual bool SetOrientation(ScreenId screenId, Orientation orientation);
+    virtual DMError SetOrientation(ScreenId screenId, Orientation orientation);
     virtual sptr<ScreenGroupInfo> GetScreenGroupInfoById(ScreenId screenId);
-    virtual std::vector<sptr<ScreenInfo>> GetAllScreenInfos();
-    virtual ScreenId MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId);
-    virtual ScreenId MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint);
+    virtual DMError GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos);
+    virtual DMError MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId);
+    virtual DMError MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint, ScreenId& screenGroupId);
     virtual void RemoveVirtualScreenFromGroup(std::vector<ScreenId>);
-    virtual bool SetScreenActiveMode(ScreenId screenId, uint32_t modeId);
+    virtual DMError SetScreenActiveMode(ScreenId screenId, uint32_t modeId);
     virtual sptr<ScreenInfo> GetScreenInfo(ScreenId screenId);
-    virtual bool SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio);
-    virtual void SetScreenRotationLocked(bool isLocked);
-    virtual bool IsScreenRotationLocked();
+    virtual DMError SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio);
+    virtual DMError SetScreenRotationLocked(bool isLocked);
+    virtual DMError IsScreenRotationLocked(bool& isLocked);
 
     // colorspace, gamut
     virtual DMError GetScreenSupportedColorGamuts(ScreenId screenId, std::vector<ScreenColorGamut>& colorGamuts);
diff --git a/dm/src/display_manager.cpp b/dm/src/display_manager.cpp
index 6a3b7c90..7797f34d 100644
--- a/dm/src/display_manager.cpp
+++ b/dm/src/display_manager.cpp
@@ -44,13 +44,13 @@ public:
     sptr<Display> GetDefaultDisplaySync();
     sptr<Display> GetDisplayById(DisplayId displayId);
     DMError HasPrivateWindow(DisplayId displayId, bool& hasPrivateWindow);
-    bool RegisterDisplayListener(sptr<IDisplayListener> listener);
-    bool UnregisterDisplayListener(sptr<IDisplayListener> listener);
+    DMError RegisterDisplayListener(sptr<IDisplayListener> listener);
+    DMError UnregisterDisplayListener(sptr<IDisplayListener> listener);
     bool SetDisplayState(DisplayState state, DisplayStateCallback callback);
-    bool RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
-    bool UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
-    bool RegisterScreenshotListener(sptr<IScreenshotListener> listener);
-    bool UnregisterScreenshotListener(sptr<IScreenshotListener> listener);
+    DMError RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
+    DMError UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
+    DMError RegisterScreenshotListener(sptr<IScreenshotListener> listener);
+    DMError UnregisterScreenshotListener(sptr<IScreenshotListener> listener);
     sptr<Display> GetDisplayByScreenId(ScreenId screenId);
     void OnRemoteDied();
 private:
@@ -243,22 +243,22 @@ void DisplayManager::Impl::ClearDisplayStateCallback()
 void DisplayManager::Impl::Clear()
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool res = true;
+    DMError res = DMError::DM_OK;
     if (displayManagerListener_ != nullptr) {
         res = SingletonContainer::Get<DisplayManagerAdapter>().UnregisterDisplayManagerAgent(
             displayManagerListener_, DisplayManagerAgentType::DISPLAY_EVENT_LISTENER);
     }
     displayManagerListener_ = nullptr;
-    if (!res) {
+    if (res != DMError::DM_OK) {
         WLOGFW("UnregisterDisplayManagerAgent DISPLAY_EVENT_LISTENER failed !");
     }
-    res = true;
+    res = DMError::DM_OK;
     if (powerEventListenerAgent_ != nullptr) {
         res = SingletonContainer::Get<DisplayManagerAdapter>().UnregisterDisplayManagerAgent(
             powerEventListenerAgent_, DisplayManagerAgentType::DISPLAY_POWER_EVENT_LISTENER);
     }
     powerEventListenerAgent_ = nullptr;
-    if (!res) {
+    if (res != DMError::DM_OK) {
         WLOGFW("UnregisterDisplayManagerAgent DISPLAY_POWER_EVENT_LISTENER failed !");
     }
     ClearDisplayStateCallback();
@@ -479,17 +479,17 @@ DMError DisplayManager::Impl::HasPrivateWindow(DisplayId displayId, bool& hasPri
     return SingletonContainer::Get<DisplayManagerAdapter>().HasPrivateWindow(displayId, hasPrivateWindow);
 }
 
-bool DisplayManager::Impl::RegisterDisplayListener(sptr<IDisplayListener> listener)
+DMError DisplayManager::Impl::RegisterDisplayListener(sptr<IDisplayListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (displayManagerListener_ == nullptr) {
         displayManagerListener_ = new DisplayManagerListener(this);
         ret = SingletonContainer::Get<DisplayManagerAdapter>().RegisterDisplayManagerAgent(
             displayManagerListener_,
             DisplayManagerAgentType::DISPLAY_EVENT_LISTENER);
     }
-    if (!ret) {
+    if (ret != DMError::DM_OK) {
         WLOGFW("RegisterDisplayManagerAgent failed !");
         displayManagerListener_ = nullptr;
     } else {
@@ -498,25 +498,25 @@ bool DisplayManager::Impl::RegisterDisplayListener(sptr<IDisplayListener> listen
     return ret;
 }
 
-bool DisplayManager::RegisterDisplayListener(sptr<IDisplayListener> listener)
+DMError DisplayManager::RegisterDisplayListener(sptr<IDisplayListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("RegisterDisplayListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterDisplayListener(listener);
 }
 
-bool DisplayManager::Impl::UnregisterDisplayListener(sptr<IDisplayListener> listener)
+DMError DisplayManager::Impl::UnregisterDisplayListener(sptr<IDisplayListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(displayListeners_.begin(), displayListeners_.end(), listener);
     if (iter == displayListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     displayListeners_.erase(iter);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (displayListeners_.empty() && displayManagerListener_ != nullptr) {
         ret = SingletonContainer::Get<DisplayManagerAdapter>().UnregisterDisplayManagerAgent(
             displayManagerListener_,
@@ -526,26 +526,26 @@ bool DisplayManager::Impl::UnregisterDisplayListener(sptr<IDisplayListener> list
     return ret;
 }
 
-bool DisplayManager::UnregisterDisplayListener(sptr<IDisplayListener> listener)
+DMError DisplayManager::UnregisterDisplayListener(sptr<IDisplayListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("UnregisterDisplayListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterDisplayListener(listener);
 }
 
-bool DisplayManager::Impl::RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
+DMError DisplayManager::Impl::RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (powerEventListenerAgent_ == nullptr) {
         powerEventListenerAgent_ = new DisplayManagerAgent(this);
         ret = SingletonContainer::Get<DisplayManagerAdapter>().RegisterDisplayManagerAgent(
             powerEventListenerAgent_,
             DisplayManagerAgentType::DISPLAY_POWER_EVENT_LISTENER);
     }
-    if (!ret) {
+    if (ret != DMError::DM_OK) {
         WLOGFW("RegisterDisplayManagerAgent failed !");
         powerEventListenerAgent_ = nullptr;
     } else {
@@ -555,25 +555,25 @@ bool DisplayManager::Impl::RegisterDisplayPowerEventListener(sptr<IDisplayPowerE
     return ret;
 }
 
-bool DisplayManager::RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
+DMError DisplayManager::RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener is nullptr");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterDisplayPowerEventListener(listener);
 }
 
-bool DisplayManager::Impl::UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
+DMError DisplayManager::Impl::UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(powerEventListeners_.begin(), powerEventListeners_.end(), listener);
     if (iter == powerEventListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     powerEventListeners_.erase(iter);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (powerEventListeners_.empty() && powerEventListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<DisplayManagerAdapter>().UnregisterDisplayManagerAgent(
             powerEventListenerAgent_,
@@ -584,26 +584,26 @@ bool DisplayManager::Impl::UnregisterDisplayPowerEventListener(sptr<IDisplayPowe
     return ret;
 }
 
-bool DisplayManager::UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
+DMError DisplayManager::UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener is nullptr");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterDisplayPowerEventListener(listener);
 }
 
-bool DisplayManager::Impl::RegisterScreenshotListener(sptr<IScreenshotListener> listener)
+DMError DisplayManager::Impl::RegisterScreenshotListener(sptr<IScreenshotListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (screenshotListenerAgent_ == nullptr) {
         screenshotListenerAgent_ = new DisplayManagerScreenshotAgent(this);
         ret = SingletonContainer::Get<DisplayManagerAdapter>().RegisterDisplayManagerAgent(
             screenshotListenerAgent_,
             DisplayManagerAgentType::SCREENSHOT_EVENT_LISTENER);
     }
-    if (!ret) {
+    if (ret != DMError::DM_OK) {
         WLOGFW("RegisterDisplayManagerAgent failed !");
         screenshotListenerAgent_ = nullptr;
     } else {
@@ -612,25 +612,25 @@ bool DisplayManager::Impl::RegisterScreenshotListener(sptr<IScreenshotListener>
     return ret;
 }
 
-bool DisplayManager::RegisterScreenshotListener(sptr<IScreenshotListener> listener)
+DMError DisplayManager::RegisterScreenshotListener(sptr<IScreenshotListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("RegisterScreenshotListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterScreenshotListener(listener);
 }
 
-bool DisplayManager::Impl::UnregisterScreenshotListener(sptr<IScreenshotListener> listener)
+DMError DisplayManager::Impl::UnregisterScreenshotListener(sptr<IScreenshotListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(screenshotListeners_.begin(), screenshotListeners_.end(), listener);
     if (iter == screenshotListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     screenshotListeners_.erase(iter);
-    bool ret = true;
+    DMError ret = DMError::DM_OK;
     if (screenshotListeners_.empty() && screenshotListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<DisplayManagerAdapter>().UnregisterDisplayManagerAgent(
             screenshotListenerAgent_,
@@ -640,11 +640,11 @@ bool DisplayManager::Impl::UnregisterScreenshotListener(sptr<IScreenshotListener
     return ret;
 }
 
-bool DisplayManager::UnregisterScreenshotListener(sptr<IScreenshotListener> listener)
+DMError DisplayManager::UnregisterScreenshotListener(sptr<IScreenshotListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("UnregisterScreenshotListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterScreenshotListener(listener);
 }
@@ -776,7 +776,7 @@ bool DisplayManager::Impl::SetDisplayState(DisplayState state, DisplayStateCallb
             displayStateAgent_ = new DisplayManagerAgent(this);
             ret = SingletonContainer::Get<DisplayManagerAdapter>().RegisterDisplayManagerAgent(
                 displayStateAgent_,
-                DisplayManagerAgentType::DISPLAY_STATE_LISTENER);
+                DisplayManagerAgentType::DISPLAY_STATE_LISTENER) == DMError::DM_OK;
         }
     }
     ret = ret && SingletonContainer::Get<DisplayManagerAdapter>().SetDisplayState(state);
diff --git a/dm/src/display_manager_adapter.cpp b/dm/src/display_manager_adapter.cpp
index 84f774b6..69699815 100644
--- a/dm/src/display_manager_adapter.cpp
+++ b/dm/src/display_manager_adapter.cpp
@@ -127,18 +127,18 @@ DMError ScreenManagerAdapter::SetVirtualScreenSurface(ScreenId screenId, sptr<Su
     return displayManagerServiceProxy_->SetVirtualScreenSurface(screenId, surface);
 }
 
-void ScreenManagerAdapter::SetScreenRotationLocked(bool isLocked)
+DMError ScreenManagerAdapter::SetScreenRotationLocked(bool isLocked)
 {
-    INIT_PROXY_CHECK_RETURN();
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
     WLOGFI("DisplayManagerAdapter::SetScreenRotationLocked");
-    displayManagerServiceProxy_->SetScreenRotationLocked(isLocked);
+    return displayManagerServiceProxy_->SetScreenRotationLocked(isLocked);
 }
 
-bool ScreenManagerAdapter::IsScreenRotationLocked()
+DMError ScreenManagerAdapter::IsScreenRotationLocked(bool& isLocked)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
     WLOGFI("DisplayManagerAdapter::IsScreenRotationLocked");
-    return displayManagerServiceProxy_->IsScreenRotationLocked();
+    return displayManagerServiceProxy_->IsScreenRotationLocked(isLocked);
 }
 
 bool ScreenManagerAdapter::SetScreenPowerForAll(ScreenPowerState state, PowerStateChangeReason reason)
@@ -153,25 +153,25 @@ ScreenPowerState ScreenManagerAdapter::GetScreenPower(ScreenId dmsScreenId)
     return displayManagerServiceProxy_->GetScreenPower(dmsScreenId);
 }
 
-bool ScreenManagerAdapter::SetOrientation(ScreenId screenId, Orientation orientation)
+DMError ScreenManagerAdapter::SetOrientation(ScreenId screenId, Orientation orientation)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
     return displayManagerServiceProxy_->SetOrientation(screenId, orientation);
 }
 
-bool BaseAdapter::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError BaseAdapter::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
     return displayManagerServiceProxy_->RegisterDisplayManagerAgent(displayManagerAgent, type);
 }
 
-bool BaseAdapter::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError BaseAdapter::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
     return displayManagerServiceProxy_->UnregisterDisplayManagerAgent(displayManagerAgent, type);
 }
@@ -301,11 +301,11 @@ void BaseAdapter::Clear()
     isProxyValid_ = false;
 }
 
-ScreenId ScreenManagerAdapter::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId)
+DMError ScreenManagerAdapter::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId)
 {
-    INIT_PROXY_CHECK_RETURN(SCREEN_ID_INVALID);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
-    return displayManagerServiceProxy_->MakeMirror(mainScreenId, mirrorScreenId);
+    return displayManagerServiceProxy_->MakeMirror(mainScreenId, mirrorScreenId, screenGroupId);
 }
 
 sptr<ScreenInfo> ScreenManagerAdapter::GetScreenInfo(ScreenId screenId)
@@ -367,18 +367,18 @@ sptr<ScreenGroupInfo> ScreenManagerAdapter::GetScreenGroupInfoById(ScreenId scre
     return displayManagerServiceProxy_->GetScreenGroupInfoById(screenId);
 }
 
-std::vector<sptr<ScreenInfo>> ScreenManagerAdapter::GetAllScreenInfos()
+DMError ScreenManagerAdapter::GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos)
 {
-    INIT_PROXY_CHECK_RETURN(std::vector<sptr<ScreenInfo>>());
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
-    return displayManagerServiceProxy_->GetAllScreenInfos();
+    return displayManagerServiceProxy_->GetAllScreenInfos(screenInfos);
 }
 
-ScreenId ScreenManagerAdapter::MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint)
+DMError ScreenManagerAdapter::MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint, ScreenId& screenGroupId)
 {
-    INIT_PROXY_CHECK_RETURN(SCREEN_ID_INVALID);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
-    return displayManagerServiceProxy_->MakeExpand(screenId, startPoint);
+    return displayManagerServiceProxy_->MakeExpand(screenId, startPoint, screenGroupId);
 }
 
 void ScreenManagerAdapter::RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens)
@@ -388,16 +388,16 @@ void ScreenManagerAdapter::RemoveVirtualScreenFromGroup(std::vector<ScreenId> sc
     displayManagerServiceProxy_->RemoveVirtualScreenFromGroup(screens);
 }
 
-bool ScreenManagerAdapter::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
+DMError ScreenManagerAdapter::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
     return displayManagerServiceProxy_->SetScreenActiveMode(screenId, modeId);
 }
 
-bool ScreenManagerAdapter::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
+DMError ScreenManagerAdapter::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(DMError::DM_ERROR_INIT_DMS_PROXY_LOCKED);
 
     return displayManagerServiceProxy_->SetVirtualPixelRatio(screenId, virtualPixelRatio);
 }
diff --git a/dm/src/screen.cpp b/dm/src/screen.cpp
index 35aa7a16..a78ee62c 100644
--- a/dm/src/screen.cpp
+++ b/dm/src/screen.cpp
@@ -120,7 +120,7 @@ bool Screen::IsReal() const
     return pImpl_->GetScreenInfo()->GetType() == ScreenType::REAL;
 }
 
-bool Screen::SetOrientation(Orientation orientation) const
+DMError Screen::SetOrientation(Orientation orientation) const
 {
     WLOGFD("set orientation %{public}u", orientation);
     return SingletonContainer::Get<ScreenManagerAdapter>().SetOrientation(GetId(), orientation);
@@ -173,11 +173,11 @@ std::vector<sptr<SupportedScreenModes>> Screen::GetSupportedModes() const
     return pImpl_->GetScreenInfo()->GetModes();
 }
 
-bool Screen::SetScreenActiveMode(uint32_t modeId)
+DMError Screen::SetScreenActiveMode(uint32_t modeId)
 {
     ScreenId screenId = GetId();
     if (modeId >= GetSupportedModes().size()) {
-        return false;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     return SingletonContainer::Get<ScreenManagerAdapter>().SetScreenActiveMode(screenId, modeId);
 }
@@ -197,12 +197,12 @@ void Screen::UpdateScreenInfo() const
     UpdateScreenInfo(screenInfo);
 }
 
-bool Screen::SetDensityDpi(uint32_t dpi) const
+DMError Screen::SetDensityDpi(uint32_t dpi) const
 {
     if (dpi > DOT_PER_INCH_MAXIMUM_VALUE || dpi < DOT_PER_INCH_MINIMUM_VALUE) {
         WLOGE("Invalid input dpi value, valid input range for DPI is %{public}u ~ %{public}u",
             DOT_PER_INCH_MINIMUM_VALUE, DOT_PER_INCH_MAXIMUM_VALUE);
-        return false;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     // Calculate display density, Density = Dpi / 160.
     float density = static_cast<float>(dpi) / 160; // 160 is the coefficient between density and dpi.
diff --git a/dm/src/screen_manager.cpp b/dm/src/screen_manager.cpp
index 9e07a0e3..babd65f4 100644
--- a/dm/src/screen_manager.cpp
+++ b/dm/src/screen_manager.cpp
@@ -38,13 +38,13 @@ public:
     ScreenId CreateVirtualScreen(VirtualScreenOption option);
     sptr<Screen> GetScreen(ScreenId screenId);
     sptr<ScreenGroup> GetScreenGroup(ScreenId screenId);
-    std::vector<sptr<Screen>> GetAllScreens();
-    bool RegisterScreenListener(sptr<IScreenListener> listener);
-    bool UnregisterScreenListener(sptr<IScreenListener> listener);
-    bool RegisterScreenGroupListener(sptr<IScreenGroupListener> listener);
-    bool UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener);
-    bool RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
-    bool UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
+    DMError GetAllScreens(std::vector<sptr<Screen>>& screens);
+    DMError RegisterScreenListener(sptr<IScreenListener> listener);
+    DMError UnregisterScreenListener(sptr<IScreenListener> listener);
+    DMError RegisterScreenGroupListener(sptr<IScreenGroupListener> listener);
+    DMError UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener);
+    DMError RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
+    DMError UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
     void OnRemoteDied();
 
 private:
@@ -53,8 +53,8 @@ private:
     void NotifyScreenChange(const sptr<ScreenInfo>& screenInfo);
     void NotifyScreenChange(const std::vector<sptr<ScreenInfo>>& screenInfos);
     bool UpdateScreenInfoLocked(sptr<ScreenInfo>);
-    bool RegisterDisplayManagerAgent();
-    bool UnregisterDisplayManagerAgent();
+    DMError RegisterDisplayManagerAgent();
+    DMError UnregisterDisplayManagerAgent();
     bool isAllListenersRemoved() const;
 
     class ScreenManagerListener;
@@ -251,10 +251,10 @@ sptr<ScreenGroup> ScreenManager::GetScreenGroup(ScreenId screenId)
     return pImpl_->GetScreenGroup(screenId);
 }
 
-std::vector<sptr<Screen>> ScreenManager::Impl::GetAllScreens()
+DMError ScreenManager::Impl::GetAllScreens(std::vector<sptr<Screen>>& screens)
 {
-    auto screenInfos = SingletonContainer::Get<ScreenManagerAdapter>().GetAllScreenInfos();
-    std::vector<sptr<Screen>> screens;
+    std::vector<sptr<ScreenInfo>> screenInfos;
+    DMError ret  = SingletonContainer::Get<ScreenManagerAdapter>().GetAllScreenInfos(screenInfos);
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     for (auto info: screenInfos) {
         if (UpdateScreenInfoLocked(info)) {
@@ -265,142 +265,142 @@ std::vector<sptr<Screen>> ScreenManager::Impl::GetAllScreens()
     for (auto screen: screens) {
         screenMap_.insert(std::make_pair(screen->GetId(), screen));
     }
-    return screens;
+    return ret;
 }
 
-std::vector<sptr<Screen>> ScreenManager::GetAllScreens()
+DMError ScreenManager::GetAllScreens(std::vector<sptr<Screen>>& screens)
 {
-    return pImpl_->GetAllScreens();
+    return pImpl_->GetAllScreens(screens);
 }
 
-bool ScreenManager::Impl::RegisterScreenListener(sptr<IScreenListener> listener)
+DMError ScreenManager::Impl::RegisterScreenListener(sptr<IScreenListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool regSucc = RegisterDisplayManagerAgent();
-    if (regSucc) {
+    DMError regSucc = RegisterDisplayManagerAgent();
+    if (regSucc == DMError::DM_OK) {
         screenListeners_.insert(listener);
     }
     return regSucc;
 }
 
-bool ScreenManager::RegisterScreenListener(sptr<IScreenListener> listener)
+DMError ScreenManager::RegisterScreenListener(sptr<IScreenListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("RegisterScreenListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterScreenListener(listener);
 }
 
-bool ScreenManager::Impl::UnregisterScreenListener(sptr<IScreenListener> listener)
+DMError ScreenManager::Impl::UnregisterScreenListener(sptr<IScreenListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(screenListeners_.begin(), screenListeners_.end(), listener);
     if (iter == screenListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     screenListeners_.erase(iter);
-    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : true;
+    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : DMError::DM_OK;
 }
 
-bool ScreenManager::UnregisterScreenListener(sptr<IScreenListener> listener)
+DMError ScreenManager::UnregisterScreenListener(sptr<IScreenListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("UnregisterScreenListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterScreenListener(listener);
 }
 
-bool ScreenManager::Impl::RegisterScreenGroupListener(sptr<IScreenGroupListener> listener)
+DMError ScreenManager::Impl::RegisterScreenGroupListener(sptr<IScreenGroupListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool regSucc = RegisterDisplayManagerAgent();
-    if (regSucc) {
+    DMError regSucc = RegisterDisplayManagerAgent();
+    if (regSucc == DMError::DM_OK) {
         screenGroupListeners_.insert(listener);
     }
     return regSucc;
 }
 
-bool ScreenManager::RegisterScreenGroupListener(sptr<IScreenGroupListener> listener)
+DMError ScreenManager::RegisterScreenGroupListener(sptr<IScreenGroupListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("RegisterScreenGroupListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterScreenGroupListener(listener);
 }
 
-bool ScreenManager::Impl::UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener)
+DMError ScreenManager::Impl::UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(screenGroupListeners_.begin(), screenGroupListeners_.end(), listener);
     if (iter == screenGroupListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     screenGroupListeners_.erase(iter);
-    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : true;
+    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : DMError::DM_OK;
 }
 
-bool ScreenManager::UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener)
+DMError ScreenManager::UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("UnregisterScreenGroupListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterScreenGroupListener(listener);
 }
 
-bool ScreenManager::Impl::RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
+DMError ScreenManager::Impl::RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
-    bool regSucc = RegisterDisplayManagerAgent();
-    if (regSucc) {
+    DMError regSucc = RegisterDisplayManagerAgent();
+    if (regSucc == DMError::DM_OK) {
         virtualScreenGroupListeners_.insert(listener);
     }
     return regSucc;
 }
 
-bool ScreenManager::RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
+DMError ScreenManager::RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("RegisterVirtualScreenGroupListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->RegisterVirtualScreenGroupListener(listener);
 }
 
-bool ScreenManager::Impl::UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
+DMError ScreenManager::Impl::UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
 {
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     auto iter = std::find(virtualScreenGroupListeners_.begin(), virtualScreenGroupListeners_.end(), listener);
     if (iter == virtualScreenGroupListeners_.end()) {
         WLOGFE("could not find this listener");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     virtualScreenGroupListeners_.erase(iter);
-    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : true;
+    return isAllListenersRemoved() ? UnregisterDisplayManagerAgent() : DMError::DM_OK;
 }
 
-bool ScreenManager::UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
+DMError ScreenManager::UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener)
 {
     if (listener == nullptr) {
         WLOGFE("UnregisterVirtualScreenGroupListener listener is nullptr.");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return pImpl_->UnregisterVirtualScreenGroupListener(listener);
 }
 
-bool ScreenManager::Impl::RegisterDisplayManagerAgent()
+DMError ScreenManager::Impl::RegisterDisplayManagerAgent()
 {
-    bool regSucc = true;
+    DMError regSucc = DMError::DM_OK;
     if (screenManagerListener_ == nullptr) {
         screenManagerListener_ = new ScreenManagerListener(this);
         regSucc = SingletonContainer::Get<ScreenManagerAdapter>().RegisterDisplayManagerAgent(
             screenManagerListener_, DisplayManagerAgentType::SCREEN_EVENT_LISTENER);
-        if (!regSucc) {
+        if (regSucc != DMError::DM_OK) {
             screenManagerListener_ = nullptr;
             WLOGFW("RegisterDisplayManagerAgent failed !");
         }
@@ -408,29 +408,29 @@ bool ScreenManager::Impl::RegisterDisplayManagerAgent()
     return regSucc;
 }
 
-bool ScreenManager::Impl::UnregisterDisplayManagerAgent()
+DMError ScreenManager::Impl::UnregisterDisplayManagerAgent()
 {
-    bool unRegSucc = true;
+    DMError unRegSucc = DMError::DM_OK;
     if (screenManagerListener_ != nullptr) {
         unRegSucc = SingletonContainer::Get<ScreenManagerAdapter>().UnregisterDisplayManagerAgent(
             screenManagerListener_, DisplayManagerAgentType::SCREEN_EVENT_LISTENER);
         screenManagerListener_ = nullptr;
-        if (!unRegSucc) {
+        if (unRegSucc != DMError::DM_OK) {
             WLOGFW("UnregisterDisplayManagerAgent failed!");
         }
     }
     return unRegSucc;
 }
 
-ScreenId ScreenManager::MakeExpand(const std::vector<ExpandOption>& options)
+DMError ScreenManager::MakeExpand(const std::vector<ExpandOption>& options, ScreenId& screenGroupId)
 {
     WLOGFI("Make expand");
     if (options.empty()) {
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     if (options.size() > MAX_SCREEN_SIZE) {
         WLOGFW("Make expand failed. The options size is bigger than %{public}u.", MAX_SCREEN_SIZE);
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     std::vector<ScreenId> screenIds;
     std::vector<Point> startPoints;
@@ -441,25 +441,25 @@ ScreenId ScreenManager::MakeExpand(const std::vector<ExpandOption>& options)
         screenIds.emplace_back(option.screenId_);
         startPoints.emplace_back(Point(option.startX_, option.startY_));
     }
-    ScreenId group = SingletonContainer::Get<ScreenManagerAdapter>().MakeExpand(screenIds, startPoints);
-    if (group == SCREEN_ID_INVALID) {
+    DMError ret = SingletonContainer::Get<ScreenManagerAdapter>().MakeExpand(screenIds, startPoints, screenGroupId);
+    if (screenGroupId == SCREEN_ID_INVALID) {
         WLOGFI("Make expand failed");
     }
-    return group;
+    return ret;
 }
 
-ScreenId ScreenManager::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId)
+DMError ScreenManager::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId)
 {
     WLOGFI("Make mirror for screen: %{public}" PRIu64"", mainScreenId);
     if (mirrorScreenId.size() > MAX_SCREEN_SIZE) {
         WLOGFW("Make Mirror failed. The mirrorScreenId size is bigger than %{public}u.", MAX_SCREEN_SIZE);
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
-    ScreenId group = SingletonContainer::Get<ScreenManagerAdapter>().MakeMirror(mainScreenId, mirrorScreenId);
-    if (group == SCREEN_ID_INVALID) {
+    DMError ret = SingletonContainer::Get<ScreenManagerAdapter>().MakeMirror(mainScreenId, mirrorScreenId, screenGroupId);
+    if (screenGroupId == SCREEN_ID_INVALID) {
         WLOGFI("create mirror failed");
     }
-    return group;
+    return ret;
 }
 
 DMError ScreenManager::RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens)
@@ -518,9 +518,9 @@ DMError ScreenManager::SetScreenRotationLocked(bool isLocked)
     return DMError::DM_OK;
 }
 
-bool ScreenManager::IsScreenRotationLocked()
+DMError ScreenManager::IsScreenRotationLocked(bool& isLocked)
 {
-    return SingletonContainer::Get<ScreenManagerAdapter>().IsScreenRotationLocked();
+    return SingletonContainer::Get<ScreenManagerAdapter>().IsScreenRotationLocked(isLocked);
 }
 
 void ScreenManager::Impl::NotifyScreenConnect(sptr<ScreenInfo> info)
diff --git a/dmserver/include/abstract_screen_controller.h b/dmserver/include/abstract_screen_controller.h
index f4cd5d4b..1ecccca2 100644
--- a/dmserver/include/abstract_screen_controller.h
+++ b/dmserver/include/abstract_screen_controller.h
@@ -62,10 +62,10 @@ public:
     DMError DestroyVirtualScreen(ScreenId screenId);
     DMError SetVirtualScreenSurface(ScreenId screenId, sptr<Surface> surface);
     void SetBuildInDefaultOrientation(Orientation orientation);
-    bool SetOrientation(ScreenId screenId, Orientation orientation, bool isFromWindow);
+    DMError SetOrientation(ScreenId screenId, Orientation orientation, bool isFromWindow);
     bool SetRotation(ScreenId screenId, Rotation rotationAfter, bool isFromWindow);
 
-    bool SetScreenActiveMode(ScreenId screenId, uint32_t modeId);
+    DMError SetScreenActiveMode(ScreenId screenId, uint32_t modeId);
     const std::shared_ptr<RSDisplayNode>& GetRSDisplayNodeByScreenId(ScreenId dmsScreenId) const;
     void UpdateRSTree(ScreenId dmsScreenId, ScreenId parentScreenId, std::shared_ptr<RSSurfaceNode>& surfaceNode,
         bool isAdd, bool isMultiDisplay);
@@ -74,7 +74,7 @@ public:
     void RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens);
     bool SetScreenPowerForAll(ScreenPowerState state, PowerStateChangeReason reason) const;
     ScreenPowerState GetScreenPower(ScreenId dmsScreenId) const;
-    bool SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio);
+    DMError SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio);
 
     // colorspace, gamut
     DMError GetScreenSupportedColorGamuts(ScreenId screenId, std::vector<ScreenColorGamut>& colorGamuts);
diff --git a/dmserver/include/display_manager_interface.h b/dmserver/include/display_manager_interface.h
index c8142927..dd94ede3 100644
--- a/dmserver/include/display_manager_interface.h
+++ b/dmserver/include/display_manager_interface.h
@@ -87,10 +87,10 @@ public:
         const sptr<IRemoteObject>& displayManagerAgent) = 0;
     virtual DMError DestroyVirtualScreen(ScreenId screenId) = 0;
     virtual DMError SetVirtualScreenSurface(ScreenId screenId, sptr<Surface> surface) = 0;
-    virtual bool SetOrientation(ScreenId screenId, Orientation orientation) = 0;
+    virtual DMError SetOrientation(ScreenId screenId, Orientation orientation) = 0;
     virtual std::shared_ptr<Media::PixelMap> GetDisplaySnapshot(DisplayId displayId) = 0;
-    virtual void SetScreenRotationLocked(bool isLocked) = 0;
-    virtual bool IsScreenRotationLocked() = 0;
+    virtual DMError SetScreenRotationLocked(bool isLocked) = 0;
+    virtual DMError IsScreenRotationLocked(bool& isLocked) = 0;
 
     // colorspace, gamut
     virtual DMError GetScreenSupportedColorGamuts(ScreenId screenId, std::vector<ScreenColorGamut>& colorGamuts) = 0;
@@ -100,9 +100,9 @@ public:
     virtual DMError SetScreenGamutMap(ScreenId screenId, ScreenGamutMap gamutMap) = 0;
     virtual DMError SetScreenColorTransform(ScreenId screenId) = 0;
 
-    virtual bool RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    virtual DMError RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) = 0;
-    virtual bool UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    virtual DMError UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) = 0;
     virtual bool WakeUpBegin(PowerStateChangeReason reason) = 0;
     virtual bool WakeUpEnd() = 0;
@@ -118,12 +118,12 @@ public:
     virtual bool SetFreeze(std::vector<DisplayId> displayIds, bool isFreeze) = 0;
     virtual sptr<ScreenInfo> GetScreenInfoById(ScreenId screenId) = 0;
     virtual sptr<ScreenGroupInfo> GetScreenGroupInfoById(ScreenId screenId) = 0;
-    virtual std::vector<sptr<ScreenInfo>> GetAllScreenInfos() = 0;
-    virtual ScreenId MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId) = 0;
-    virtual ScreenId MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint) = 0;
+    virtual DMError GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos) = 0;
+    virtual DMError MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenIds, ScreenId& screenGroupId) = 0;
+    virtual DMError MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoints, ScreenId& screenGroupId) = 0;
     virtual void RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens) = 0;
-    virtual bool SetScreenActiveMode(ScreenId screenId, uint32_t modeId) = 0;
-    virtual bool SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) = 0;
+    virtual DMError SetScreenActiveMode(ScreenId screenId, uint32_t modeId) = 0;
+    virtual DMError SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) = 0;
 };
 } // namespace OHOS::Rosen
 
diff --git a/dmserver/include/display_manager_proxy.h b/dmserver/include/display_manager_proxy.h
index 48de3a71..74f3825d 100644
--- a/dmserver/include/display_manager_proxy.h
+++ b/dmserver/include/display_manager_proxy.h
@@ -40,10 +40,10 @@ public:
         const sptr<IRemoteObject>& displayManagerAgent) override;
     DMError DestroyVirtualScreen(ScreenId screenId) override;
     DMError SetVirtualScreenSurface(ScreenId screenId, sptr<Surface> surface) override;
-    bool SetOrientation(ScreenId screenId, Orientation orientation) override;
+    DMError SetOrientation(ScreenId screenId, Orientation orientation) override;
     std::shared_ptr<Media::PixelMap> GetDisplaySnapshot(DisplayId displayId) override;
-    bool IsScreenRotationLocked() override;
-    void SetScreenRotationLocked(bool isLocked) override;
+    DMError IsScreenRotationLocked(bool& isLocked) override;
+    DMError SetScreenRotationLocked(bool isLocked) override;
 
     // colorspace, gamut
     DMError GetScreenSupportedColorGamuts(ScreenId screenId, std::vector<ScreenColorGamut>& colorGamuts) override;
@@ -53,9 +53,9 @@ public:
     DMError SetScreenGamutMap(ScreenId screenId, ScreenGamutMap gamutMap) override;
     DMError SetScreenColorTransform(ScreenId screenId) override;
 
-    bool RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    DMError RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) override;
-    bool UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    DMError UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) override;
     bool WakeUpBegin(PowerStateChangeReason reason) override;
     bool WakeUpEnd() override;
@@ -69,14 +69,14 @@ public:
     sptr<CutoutInfo> GetCutoutInfo(DisplayId displayId) override;
     void NotifyDisplayEvent(DisplayEvent event) override;
     bool SetFreeze(std::vector<DisplayId> displayIds, bool isFreeze) override;
-    ScreenId MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId) override;
+    DMError MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId) override;
     sptr<ScreenInfo> GetScreenInfoById(ScreenId screenId) override;
     sptr<ScreenGroupInfo> GetScreenGroupInfoById(ScreenId screenId) override;
-    std::vector<sptr<ScreenInfo>> GetAllScreenInfos() override;
-    ScreenId MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint) override;
+    DMError GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screens) override;
+    DMError MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint, ScreenId& screenGroupId) override;
     void RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens) override;
-    bool SetScreenActiveMode(ScreenId screenId, uint32_t modeId) override;
-    bool SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) override;
+    DMError SetScreenActiveMode(ScreenId screenId, uint32_t modeId) override;
+    DMError SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) override;
 
 private:
     static inline BrokerDelegator<DisplayManagerProxy> delegator_;
diff --git a/dmserver/include/display_manager_service.h b/dmserver/include/display_manager_service.h
index ccf579f9..b99d003d 100644
--- a/dmserver/include/display_manager_service.h
+++ b/dmserver/include/display_manager_service.h
@@ -51,15 +51,15 @@ public:
         const sptr<IRemoteObject>& displayManagerAgent) override;
     DMError DestroyVirtualScreen(ScreenId screenId) override;
     DMError SetVirtualScreenSurface(ScreenId screenId, sptr<Surface> surface) override;
-    bool IsScreenRotationLocked() override;
-    void SetScreenRotationLocked(bool isLocked) override;
+    DMError IsScreenRotationLocked(bool& isLocked) override;
+    DMError SetScreenRotationLocked(bool isLocked) override;
 
     sptr<DisplayInfo> GetDefaultDisplayInfo() override;
     sptr<DisplayInfo> GetDisplayInfoById(DisplayId displayId) override;
     sptr<DisplayInfo> GetDisplayInfoByScreen(ScreenId screenId) override;
     sptr<CutoutInfo> GetCutoutInfo(DisplayId displayId) override;
-    bool SetOrientation(ScreenId screenId, Orientation orientation) override;
-    bool SetOrientationFromWindow(ScreenId screenId, Orientation orientation);
+    DMError SetOrientation(ScreenId screenId, Orientation orientation) override;
+    DMError SetOrientationFromWindow(ScreenId screenId, Orientation orientation);
     bool SetRotationFromWindow(ScreenId screenId, Rotation targetRotation);
     void SetGravitySensorSubscriptionEnabled();
     std::shared_ptr<Media::PixelMap> GetDisplaySnapshot(DisplayId displayId) override;
@@ -73,9 +73,9 @@ public:
     DMError SetScreenGamutMap(ScreenId screenId, ScreenGamutMap gamutMap) override;
     DMError SetScreenColorTransform(ScreenId screenId) override;
 
-    bool RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    DMError RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) override;
-    bool UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+    DMError UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
         DisplayManagerAgentType type) override;
     bool WakeUpBegin(PowerStateChangeReason reason) override;
     bool WakeUpEnd() override;
@@ -91,17 +91,17 @@ public:
     void NotifyDisplayEvent(DisplayEvent event) override;
     bool SetFreeze(std::vector<DisplayId> displayIds, bool isFreeze) override;
 
-    ScreenId MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId) override;
-    ScreenId MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint) override;
+    DMError MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenIds, ScreenId& screenGroupId) override;
+    DMError MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoints, ScreenId& screenGroupId) override;
     void RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens) override;
     sptr<ScreenInfo> GetScreenInfoById(ScreenId screenId) override;
     sptr<ScreenGroupInfo> GetScreenGroupInfoById(ScreenId screenId) override;
     ScreenId GetScreenGroupIdByScreenId(ScreenId screenId);
-    std::vector<sptr<ScreenInfo>> GetAllScreenInfos() override;
+    DMError GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos) override;
 
     std::vector<DisplayId> GetAllDisplayIds() override;
-    bool SetScreenActiveMode(ScreenId screenId, uint32_t modeId) override;
-    bool SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) override;
+    DMError SetScreenActiveMode(ScreenId screenId, uint32_t modeId) override;
+    DMError SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio) override;
     void RegisterDisplayChangeListener(sptr<IDisplayChangeListener> listener);
     void RegisterWindowInfoQueriedListener(const sptr<IWindowInfoQueriedListener>& listener);
     void RegisterRSScreenChangeListener(const sptr<IRSScreenChangeListener>& listener);
diff --git a/dmserver/include/display_manager_service_inner.h b/dmserver/include/display_manager_service_inner.h
index d3e4c28a..efded300 100644
--- a/dmserver/include/display_manager_service_inner.h
+++ b/dmserver/include/display_manager_service_inner.h
@@ -47,7 +47,7 @@ public:
     void UpdateRSTree(DisplayId displayId, DisplayId parentDisplayId, std::shared_ptr<RSSurfaceNode>& surfaceNode,
         bool isAdd, bool isMultiDisplay);
     void RegisterDisplayChangeListener(sptr<IDisplayChangeListener> listener);
-    bool SetOrientationFromWindow(DisplayId displayId, Orientation orientation);
+    DMError SetOrientationFromWindow(DisplayId displayId, Orientation orientation);
     bool SetRotationFromWindow(DisplayId displayId, Rotation targetRotation);
     void SetGravitySensorSubscriptionEnabled();
     void RegisterWindowInfoQueriedListener(const sptr<IWindowInfoQueriedListener>& listener);
diff --git a/dmserver/include/screen_rotation_controller.h b/dmserver/include/screen_rotation_controller.h
index 6ffe7545..793d79df 100644
--- a/dmserver/include/screen_rotation_controller.h
+++ b/dmserver/include/screen_rotation_controller.h
@@ -76,7 +76,7 @@ private:
     static bool IsCurrentDisplayVertical();
     static bool IsCurrentDisplayHorizontal();
     static bool IsSensorRelatedOrientation(Orientation orientation);
-    
+
     static void ProcessRotationMapping();
     static void ProcessSwitchToAutoRotationPortrait(DeviceRotation rotation);
     static void ProcessSwitchToAutoRotationLandscape(DeviceRotation rotation);
diff --git a/dmserver/src/abstract_screen_controller.cpp b/dmserver/src/abstract_screen_controller.cpp
index 78a2c83f..af46ea08 100644
--- a/dmserver/src/abstract_screen_controller.cpp
+++ b/dmserver/src/abstract_screen_controller.cpp
@@ -625,17 +625,17 @@ void AbstractScreenController::SetBuildInDefaultOrientation(Orientation orientat
     }
 }
 
-bool AbstractScreenController::SetOrientation(ScreenId screenId, Orientation newOrientation, bool isFromWindow)
+DMError AbstractScreenController::SetOrientation(ScreenId screenId, Orientation newOrientation, bool isFromWindow)
 {
     WLOGD("set orientation. screen %{public}" PRIu64" orientation %{public}u", screenId, newOrientation);
     auto screen = GetAbstractScreen(screenId);
     if (screen == nullptr) {
         WLOGFE("fail to set orientation, cannot find screen %{public}" PRIu64"", screenId);
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     if (screen->isScreenGroup_) {
         WLOGE("cannot set orientation to the combination. screen: %{public}" PRIu64"", screenId);
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     if (isFromWindow) {
         if (newOrientation == Orientation::UNSPECIFIED) {
@@ -646,7 +646,7 @@ bool AbstractScreenController::SetOrientation(ScreenId screenId, Orientation new
     }
     if (screen->orientation_ == newOrientation) {
         WLOGI("skip setting orientation. screen %{public}" PRIu64" orientation %{public}u", screenId, newOrientation);
-        return true;
+        return DMError::DM_OK;
     }
     if (isFromWindow) {
         ScreenRotationController::ProcessOrientationSwitch(newOrientation);
@@ -657,7 +657,7 @@ bool AbstractScreenController::SetOrientation(ScreenId screenId, Orientation new
     }
     if (!screen->SetOrientation(newOrientation)) {
         WLOGE("fail to set rotation, screen %{public}" PRIu64"", screenId);
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
 
     // Notify rotation event to ScreenManager
@@ -666,7 +666,7 @@ bool AbstractScreenController::SetOrientation(ScreenId screenId, Orientation new
     if (abstractScreenCallback_ != nullptr) {
         abstractScreenCallback_->onChange_(screen, DisplayChangeEvent::UPDATE_ORIENTATION);
     }
-    return true;
+    return DMError::DM_OK;
 }
 
 void AbstractScreenController::SetScreenRotateAnimation(
@@ -804,12 +804,12 @@ DMError AbstractScreenController::SetScreenColorTransform(ScreenId screenId)
     return screen->SetScreenColorTransform();
 }
 
-bool AbstractScreenController::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
+DMError AbstractScreenController::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
 {
     WLOGI("SetScreenActiveMode: RsScreenId: %{public}" PRIu64", modeId: %{public}u", screenId, modeId);
     if (screenId == SCREEN_ID_INVALID) {
         WLOGFE("SetScreenActiveMode: invalid screenId");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     uint32_t usedModeId = 0;
     {
@@ -817,12 +817,12 @@ bool AbstractScreenController::SetScreenActiveMode(ScreenId screenId, uint32_t m
         auto screen = GetAbstractScreen(screenId);
         if (screen == nullptr) {
             WLOGFE("SetScreenActiveMode: Get AbstractScreen failed");
-            return false;
+            return DMError::DM_ERROR_NULLPTR;
         }
         ScreenId rsScreenId = SCREEN_ID_INVALID;
         if (!screenIdManager_.ConvertToRsScreenId(screenId, rsScreenId)) {
             WLOGFE("SetScreenActiveMode: No corresponding rsId");
-            return false;
+            return DMError::DM_ERROR_NULLPTR;
         }
         rsInterface_.SetScreenActiveMode(rsScreenId, modeId);
         usedModeId = static_cast<uint32_t>(screen->activeIdx_);
@@ -837,7 +837,7 @@ bool AbstractScreenController::SetScreenActiveMode(ScreenId screenId, uint32_t m
         };
         controllerHandler_->PostTask(func, AppExecFwk::EventQueue::Priority::HIGH);
     }
-    return true;
+    return DMError::DM_OK;
 }
 
 void AbstractScreenController::ProcessScreenModeChanged(ScreenId dmsScreenId)
@@ -1243,22 +1243,22 @@ ScreenPowerState AbstractScreenController::GetScreenPower(ScreenId dmsScreenId)
     return state;
 }
 
-bool AbstractScreenController::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
+DMError AbstractScreenController::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
 {
     WLOGD("set virtual pixel ratio. screen %{public}" PRIu64" virtualPixelRatio %{public}f",
         screenId, virtualPixelRatio);
     auto screen = GetAbstractScreen(screenId);
     if (screen == nullptr) {
         WLOGFE("fail to set virtual pixel ratio, cannot find screen %{public}" PRIu64"", screenId);
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     if (screen->isScreenGroup_) {
         WLOGE("cannot set virtual pixel ratio to the combination. screen: %{public}" PRIu64"", screenId);
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     if (fabs(screen->virtualPixelRatio_ - virtualPixelRatio) < 1e-6) {
         WLOGE("The density is equivalent to the original value, no update operation is required, aborted.");
-        return true;
+        return DMError::DM_OK;
     }
     screen->SetVirtualPixelRatio(virtualPixelRatio);
     // Notify rotation event to AbstractDisplayController
@@ -1266,6 +1266,6 @@ bool AbstractScreenController::SetVirtualPixelRatio(ScreenId screenId, float vir
         abstractScreenCallback_->onChange_(screen, DisplayChangeEvent::DISPLAY_VIRTUAL_PIXEL_RATIO_CHANGED);
     }
     NotifyScreenChanged(screen->ConvertToScreenInfo(), ScreenChangeEvent::VIRTUAL_PIXEL_RATIO_CHANGED);
-    return true;
+    return DMError::DM_OK;
 }
 } // namespace OHOS::Rosen
diff --git a/dmserver/src/display_manager_proxy.cpp b/dmserver/src/display_manager_proxy.cpp
index 561fdbd9..a2443027 100644
--- a/dmserver/src/display_manager_proxy.cpp
+++ b/dmserver/src/display_manager_proxy.cpp
@@ -229,12 +229,12 @@ DMError DisplayManagerProxy::SetVirtualScreenSurface(ScreenId screenId, sptr<Sur
     return static_cast<DMError>(reply.ReadInt32());
 }
 
-bool DisplayManagerProxy::SetOrientation(ScreenId screenId, Orientation orientation)
+DMError DisplayManagerProxy::SetOrientation(ScreenId screenId, Orientation orientation)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("fail to set orientation: remote is null");
-        return false;
+        return DMError::DM_ERROR_REMOTE_CREATE_FAILED;
     }
 
     MessageParcel data;
@@ -242,22 +242,22 @@ bool DisplayManagerProxy::SetOrientation(ScreenId screenId, Orientation orientat
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("fail to set orientation: WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUint64(static_cast<uint64_t>(screenId))) {
         WLOGFW("fail to set orientation: Write screenId failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUint32(static_cast<uint32_t>(orientation))) {
         WLOGFW("fail to set orientation: Write orientation failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SET_ORIENTATION),
         data, reply, option) != ERR_NONE) {
         WLOGFW("fail to set orientation: SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return reply.ReadBool();
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
 std::shared_ptr<Media::PixelMap> DisplayManagerProxy::GetDisplaySnapshot(DisplayId displayId)
@@ -480,7 +480,7 @@ DMError DisplayManagerProxy::SetScreenColorTransform(ScreenId screenId)
     return static_cast<DMError>(reply.ReadInt32());
 }
 
-bool DisplayManagerProxy::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError DisplayManagerProxy::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
     MessageParcel data;
@@ -488,28 +488,28 @@ bool DisplayManagerProxy::RegisterDisplayManagerAgent(const sptr<IDisplayManager
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_WRITE_INTERFACE_TOKEN_FAILED;
     }
 
     if (!data.WriteRemoteObject(displayManagerAgent->AsObject())) {
         WLOGFE("Write IDisplayManagerAgent failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteUint32(static_cast<uint32_t>(type))) {
         WLOGFE("Write DisplayManagerAgent type failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     if (Remote()->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_REGISTER_DISPLAY_MANAGER_AGENT),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return reply.ReadBool();
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
-bool DisplayManagerProxy::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError DisplayManagerProxy::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
     MessageParcel data;
@@ -517,25 +517,25 @@ bool DisplayManagerProxy::UnregisterDisplayManagerAgent(const sptr<IDisplayManag
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_WRITE_INTERFACE_TOKEN_FAILED;
     }
 
     if (!data.WriteRemoteObject(displayManagerAgent->AsObject())) {
         WLOGFE("Write IWindowManagerAgent failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteUint32(static_cast<uint32_t>(type))) {
         WLOGFE("Write DisplayManagerAgent type failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     if (Remote()->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_UNREGISTER_DISPLAY_MANAGER_AGENT),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return reply.ReadBool();
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
 bool DisplayManagerProxy::WakeUpBegin(PowerStateChangeReason reason)
@@ -816,12 +816,12 @@ bool DisplayManagerProxy::SetFreeze(std::vector<DisplayId> displayIds, bool isFr
     return true;
 }
 
-ScreenId DisplayManagerProxy::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId)
+DMError DisplayManagerProxy::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("create mirror fail: remote is null");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MessageParcel data;
@@ -829,20 +829,22 @@ ScreenId DisplayManagerProxy::MakeMirror(ScreenId mainScreenId, std::vector<Scre
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("create mirror fail: WriteInterfaceToken failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     bool res = data.WriteUint64(static_cast<uint64_t>(mainScreenId)) &&
         data.WriteUInt64Vector(mirrorScreenId);
     if (!res) {
         WLOGFE("create mirror fail: data write failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SCREEN_MAKE_MIRROR),
         data, reply, option) != ERR_NONE) {
         WLOGFW("create mirror fail: SendRequest failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return static_cast<ScreenId>(reply.ReadUint64());
+    DMError ret = static_cast<DMError>(reply.ReadInt32());
+    screenGroupId = static_cast<ScreenId>(reply.ReadUint64());
+    return ret;
 }
 
 sptr<ScreenInfo> DisplayManagerProxy::GetScreenInfoById(ScreenId screenId)
@@ -915,13 +917,12 @@ sptr<ScreenGroupInfo> DisplayManagerProxy::GetScreenGroupInfoById(ScreenId scree
     return info;
 }
 
-std::vector<sptr<ScreenInfo>> DisplayManagerProxy::GetAllScreenInfos()
+DMError DisplayManagerProxy::GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos)
 {
-    std::vector<sptr<ScreenInfo>> screenInfos;
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("GetAllScreenInfos: remote is nullptr");
-        return screenInfos;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MessageParcel data;
@@ -929,24 +930,24 @@ std::vector<sptr<ScreenInfo>> DisplayManagerProxy::GetAllScreenInfos()
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("GetAllScreenInfos: WriteInterfaceToken failed");
-        return screenInfos;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_GET_ALL_SCREEN_INFOS),
         data, reply, option) != ERR_NONE) {
         WLOGFW("GetAllScreenInfos: SendRequest failed");
-        return screenInfos;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MarshallingHelper::UnmarshallingVectorParcelableObj<ScreenInfo>(reply, screenInfos);
-    return screenInfos;
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
-ScreenId DisplayManagerProxy::MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint)
+DMError DisplayManagerProxy::MakeExpand(std::vector<ScreenId> screenId, std::vector<Point> startPoint, ScreenId& screenGroupId)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("MakeExpand: remote is null");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MessageParcel data;
@@ -954,24 +955,26 @@ ScreenId DisplayManagerProxy::MakeExpand(std::vector<ScreenId> screenId, std::ve
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("MakeExpand: WriteInterfaceToken failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUInt64Vector(screenId)) {
         WLOGFE("MakeExpand: write screenId failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!MarshallingHelper::MarshallingVectorObj<Point>(data, startPoint, [](Parcel& parcel, const Point& point) {
             return parcel.WriteInt32(point.posX_) && parcel.WriteInt32(point.posY_);
         })) {
         WLOGFE("MakeExpand: write startPoint failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SCREEN_MAKE_EXPAND),
         data, reply, option) != ERR_NONE) {
         WLOGFE("MakeExpand: SendRequest failed");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return static_cast<ScreenId>(reply.ReadUint64());
+    DMError ret = static_cast<DMError>(reply.ReadInt32());
+    screenGroupId = static_cast<ScreenId>(reply.ReadUint64());
+    return ret;
 }
 
 void DisplayManagerProxy::RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens)
@@ -1001,12 +1004,12 @@ void DisplayManagerProxy::RemoveVirtualScreenFromGroup(std::vector<ScreenId> scr
     }
 }
 
-bool DisplayManagerProxy::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
+DMError DisplayManagerProxy::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("SetScreenActiveMode: remote is null");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MessageParcel data;
@@ -1014,26 +1017,26 @@ bool DisplayManagerProxy::SetScreenActiveMode(ScreenId screenId, uint32_t modeId
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("SetScreenActiveMode: WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUint64(screenId) || !data.WriteUint32(modeId)) {
         WLOGFE("SetScreenActiveMode: write screenId/modeId failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SET_SCREEN_ACTIVE_MODE),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SetScreenActiveMode: SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return reply.ReadBool();
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
-bool DisplayManagerProxy::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
+DMError DisplayManagerProxy::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("SetVirtualPixelRatio: remote is null");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
 
     MessageParcel data;
@@ -1041,49 +1044,50 @@ bool DisplayManagerProxy::SetVirtualPixelRatio(ScreenId screenId, float virtualP
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("SetVirtualPixelRatio: WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUint64(screenId) || !data.WriteFloat(virtualPixelRatio)) {
         WLOGFE("SetVirtualPixelRatio: write screenId/modeId failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SET_VIRTUAL_PIXEL_RATIO),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SetVirtualPixelRatio: SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    return reply.ReadBool();
+    return static_cast<DMError>(reply.ReadInt32());
 }
 
-bool DisplayManagerProxy::IsScreenRotationLocked()
+DMError DisplayManagerProxy::IsScreenRotationLocked(bool& isLocked)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("IsScreenRotationLocked: remote is nullptr");
-        return false;
+        return DMError::DM_ERROR_REMOTE_CREATE_FAILED;
     }
     MessageParcel data;
     MessageParcel reply;
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("IsScreenRotationLocked: WriteInterfaceToken failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_IS_SCREEN_ROTATION_LOCKED),
         data, reply, option) != ERR_NONE) {
         WLOGFW("IsScreenRotationLocked: SendRequest failed");
-        return false;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
-    bool isLocked = reply.ReadBool();
-    return isLocked;
+    DMError ret = static_cast<DMError>(reply.ReadInt32());
+    isLocked = reply.ReadBool();
+    return ret;
 }
 
-void DisplayManagerProxy::SetScreenRotationLocked(bool isLocked)
+DMError DisplayManagerProxy::SetScreenRotationLocked(bool isLocked)
 {
     sptr<IRemoteObject> remote = Remote();
     if (remote == nullptr) {
         WLOGFW("SetScreenRotationLocked: remote is null");
-        return;
+        return DMError::DM_ERROR_REMOTE_CREATE_FAILED;
     }
 
     MessageParcel data;
@@ -1091,16 +1095,17 @@ void DisplayManagerProxy::SetScreenRotationLocked(bool isLocked)
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("SetScreenRotationLocked: WriteInterfaceToken failed");
-        return;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (!data.WriteBool(isLocked)) {
         WLOGFE("SetScreenRotationLocked: write isLocked failed");
-        return;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
     if (remote->SendRequest(static_cast<uint32_t>(DisplayManagerMessage::TRANS_ID_SET_SCREEN_ROTATION_LOCKED),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SetScreenRotationLocked: SendRequest failed");
-        return;
+        return DMError::DM_ERROR_IPC_FAILED;
     }
+    return static_cast<DMError>(reply.ReadInt32());
 }
 } // namespace OHOS::Rosen
\ No newline at end of file
diff --git a/dmserver/src/display_manager_service.cpp b/dmserver/src/display_manager_service.cpp
index 4b105813..1fb32bcc 100644
--- a/dmserver/src/display_manager_service.cpp
+++ b/dmserver/src/display_manager_service.cpp
@@ -152,7 +152,7 @@ DMError DisplayManagerService::HasPrivateWindow(DisplayId displayId, bool& hasPr
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("check has private window permission denied!");
-        return DMError::DM_ERROR_INVALID_PERMISSION;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     std::vector<DisplayId> displayIds = GetAllDisplayIds();
     auto iter = std::find(displayIds.begin(), displayIds.end(), displayId);
@@ -239,7 +239,7 @@ DMError DisplayManagerService::DestroyVirtualScreen(ScreenId screenId)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("destory virtual screen permission denied!");
-        return DMError::DM_ERROR_INVALID_PERMISSION;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     if (!accessTokenIdMaps_.isExistAndRemove(screenId, IPCSkeleton::GetCallingTokenID())) {
         return DMError::DM_ERROR_INVALID_CALLING;
@@ -264,21 +264,21 @@ DMError DisplayManagerService::SetVirtualScreenSurface(ScreenId screenId, sptr<S
     return DMError::DM_ERROR_INVALID_CALLING;
 }
 
-bool DisplayManagerService::SetOrientation(ScreenId screenId, Orientation orientation)
+DMError DisplayManagerService::SetOrientation(ScreenId screenId, Orientation orientation)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set orientation permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     if (orientation < Orientation::UNSPECIFIED || orientation > Orientation::REVERSE_HORIZONTAL) {
         WLOGFE("SetOrientation::orientation: %{public}u", static_cast<uint32_t>(orientation));
-        return false;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:SetOrientation(%" PRIu64")", screenId);
     return abstractScreenController_->SetOrientation(screenId, orientation, false);
 }
 
-bool DisplayManagerService::SetOrientationFromWindow(ScreenId screenId, Orientation orientation)
+DMError DisplayManagerService::SetOrientationFromWindow(ScreenId screenId, Orientation orientation)
 {
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:SetOrientationFromWindow(%" PRIu64")", screenId);
     return abstractScreenController_->SetOrientation(screenId, orientation, true);
@@ -358,32 +358,32 @@ void DisplayManagerService::OnStop()
     WLOGFI("ready to stop display service.");
 }
 
-bool DisplayManagerService::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError DisplayManagerService::RegisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
     if (type == DisplayManagerAgentType::SCREEN_EVENT_LISTENER && !Permission::IsSystemCalling()) {
         WLOGFE("register display manager agent permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     if ((displayManagerAgent == nullptr) || (displayManagerAgent->AsObject() == nullptr)) {
         WLOGFE("displayManagerAgent invalid");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
-    return DisplayManagerAgentController::GetInstance().RegisterDisplayManagerAgent(displayManagerAgent, type);
+    return DisplayManagerAgentController::GetInstance().RegisterDisplayManagerAgent(displayManagerAgent, type) ? DMError::DM_OK : DMError::DM_ERROR_NULLPTR;
 }
 
-bool DisplayManagerService::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
+DMError DisplayManagerService::UnregisterDisplayManagerAgent(const sptr<IDisplayManagerAgent>& displayManagerAgent,
     DisplayManagerAgentType type)
 {
     if (type == DisplayManagerAgentType::SCREEN_EVENT_LISTENER && !Permission::IsSystemCalling()) {
         WLOGFE("unregister display manager agent permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     if ((displayManagerAgent == nullptr) || (displayManagerAgent->AsObject() == nullptr)) {
         WLOGFE("displayManagerAgent invalid");
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
-    return DisplayManagerAgentController::GetInstance().UnregisterDisplayManagerAgent(displayManagerAgent, type);
+    return DisplayManagerAgentController::GetInstance().UnregisterDisplayManagerAgent(displayManagerAgent, type) ? DMError::DM_OK : DMError::DM_ERROR_NULLPTR;
 }
 
 bool DisplayManagerService::WakeUpBegin(PowerStateChangeReason reason)
@@ -493,11 +493,11 @@ bool DisplayManagerService::SetFreeze(std::vector<DisplayId> displayIds, bool is
     return true;
 }
 
-ScreenId DisplayManagerService::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenIds)
+DMError DisplayManagerService::MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenIds, ScreenId& screenGroupId)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("make mirror permission denied!");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("MakeMirror. mainScreenId :%{public}" PRIu64"", mainScreenId);
     auto allMirrorScreenIds = abstractScreenController_->GetAllValidScreenIds(mirrorScreenIds);
@@ -509,18 +509,19 @@ ScreenId DisplayManagerService::MakeMirror(ScreenId mainScreenId, std::vector<Sc
     if (mainScreen == nullptr || allMirrorScreenIds.empty()) {
         WLOGFI("create mirror fail. main screen :%{public}" PRIu64", screens' size:%{public}u",
             mainScreenId, static_cast<uint32_t>(allMirrorScreenIds.size()));
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:MakeMirror");
     if (!abstractScreenController_->MakeMirror(mainScreenId, allMirrorScreenIds)) {
         WLOGFE("make mirror failed.");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NULLPTR;
     }
     if (abstractScreenController_->GetAbstractScreenGroup(mainScreen->groupDmsId_) == nullptr) {
         WLOGFE("get screen group failed.");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NULLPTR;
     }
-    return mainScreen->groupDmsId_;
+    screenGroupId = mainScreen->groupDmsId_;
+    return DMError::DM_OK;
 }
 
 void DisplayManagerService::RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens)
@@ -575,14 +576,13 @@ std::vector<DisplayId> DisplayManagerService::GetAllDisplayIds()
     return abstractDisplayController_->GetAllDisplayIds();
 }
 
-std::vector<sptr<ScreenInfo>> DisplayManagerService::GetAllScreenInfos()
+DMError DisplayManagerService::GetAllScreenInfos(std::vector<sptr<ScreenInfo>>& screenInfos)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("get all screen infos permission denied!");
-        return std::vector<sptr<ScreenInfo>>();
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     std::vector<ScreenId> screenIds = abstractScreenController_->GetAllScreenIds();
-    std::vector<sptr<ScreenInfo>> screenInfos;
     for (auto screenId: screenIds) {
         auto screenInfo = GetScreenInfoById(screenId);
         if (screenInfo == nullptr) {
@@ -591,20 +591,20 @@ std::vector<sptr<ScreenInfo>> DisplayManagerService::GetAllScreenInfos()
         }
         screenInfos.emplace_back(screenInfo);
     }
-    return screenInfos;
+    return DMError::DM_OK;
 }
 
-ScreenId DisplayManagerService::MakeExpand(std::vector<ScreenId> expandScreenIds, std::vector<Point> startPoints)
+DMError DisplayManagerService::MakeExpand(std::vector<ScreenId> expandScreenIds, std::vector<Point> startPoints, ScreenId& screenGroupId)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("make expand permission denied!");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     if (expandScreenIds.empty() || startPoints.empty() || expandScreenIds.size() != startPoints.size()) {
         WLOGFI("create expand fail, input params is invalid. "
             "screenId vector size :%{public}ud, startPoint vector size :%{public}ud",
             static_cast<uint32_t>(expandScreenIds.size()), static_cast<uint32_t>(startPoints.size()));
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_INVALID_PARAM;
     }
     std::map<ScreenId, Point> pointsMap;
     uint32_t size = expandScreenIds.size();
@@ -623,7 +623,7 @@ ScreenId DisplayManagerService::MakeExpand(std::vector<ScreenId> expandScreenIds
     }
     if (allExpandScreenIds.empty()) {
         WLOGFE("allExpandScreenIds is empty. make expand failed.");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NULLPTR;
     }
     std::shared_ptr<RSDisplayNode> rsDisplayNode;
     std::vector<Point> points;
@@ -638,53 +638,56 @@ ScreenId DisplayManagerService::MakeExpand(std::vector<ScreenId> expandScreenIds
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:MakeExpand");
     if (!abstractScreenController_->MakeExpand(allExpandScreenIds, points)) {
         WLOGFE("make expand failed.");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NULLPTR;
     }
     auto screen = abstractScreenController_->GetAbstractScreen(allExpandScreenIds[0]);
     if (screen == nullptr || abstractScreenController_->GetAbstractScreenGroup(screen->groupDmsId_) == nullptr) {
         WLOGFE("get screen group failed.");
-        return SCREEN_ID_INVALID;
+        return DMError::DM_ERROR_NULLPTR;
     }
-    return screen->groupDmsId_;
+    screenGroupId = screen->groupDmsId_;
+    return DMError::DM_OK;
 }
 
-bool DisplayManagerService::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
+DMError DisplayManagerService::SetScreenActiveMode(ScreenId screenId, uint32_t modeId)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set screen active permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:SetScreenActiveMode(%" PRIu64", %u)", screenId, modeId);
     return abstractScreenController_->SetScreenActiveMode(screenId, modeId);
 }
 
-bool DisplayManagerService::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
+DMError DisplayManagerService::SetVirtualPixelRatio(ScreenId screenId, float virtualPixelRatio)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set virtual pixel permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "dms:SetVirtualPixelRatio(%" PRIu64", %f)", screenId,
         virtualPixelRatio);
     return abstractScreenController_->SetVirtualPixelRatio(screenId, virtualPixelRatio);
 }
 
-bool DisplayManagerService::IsScreenRotationLocked()
+DMError DisplayManagerService::IsScreenRotationLocked(bool& isLocked)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("is screen rotation locked permission denied!");
-        return false;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
-    return ScreenRotationController::IsScreenRotationLocked();
+    isLocked = ScreenRotationController::IsScreenRotationLocked();
+    return DMError::DM_OK;
 }
 
-void DisplayManagerService::SetScreenRotationLocked(bool isLocked)
+DMError DisplayManagerService::SetScreenRotationLocked(bool isLocked)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set screen rotation locked permission denied!");
-        return;
+        return DMError::DM_ERROR_NOT_SYSTEM_APP;
     }
     ScreenRotationController::SetScreenRotationLocked(isLocked);
+    return DMError::DM_OK;
 }
 
 void DisplayManagerService::SetGravitySensorSubscriptionEnabled()
diff --git a/dmserver/src/display_manager_service_inner.cpp b/dmserver/src/display_manager_service_inner.cpp
index 96d05714..7f8c7456 100644
--- a/dmserver/src/display_manager_service_inner.cpp
+++ b/dmserver/src/display_manager_service_inner.cpp
@@ -133,11 +133,11 @@ void DisplayManagerServiceInner::RegisterDisplayChangeListener(sptr<IDisplayChan
     DisplayManagerService::GetInstance().RegisterDisplayChangeListener(listener);
 }
 
-bool DisplayManagerServiceInner::SetOrientationFromWindow(DisplayId displayId, Orientation orientation)
+DMError DisplayManagerServiceInner::SetOrientationFromWindow(DisplayId displayId, Orientation orientation)
 {
     auto displayInfo = GetDisplayById(displayId);
     if (displayInfo == nullptr) {
-        return false;
+        return DMError::DM_ERROR_NULLPTR;
     }
     return DisplayManagerService::GetInstance().
         SetOrientationFromWindow(displayInfo->GetScreenId(), orientation);
diff --git a/dmserver/src/display_manager_stub.cpp b/dmserver/src/display_manager_stub.cpp
index add7a44f..ae806134 100644
--- a/dmserver/src/display_manager_stub.cpp
+++ b/dmserver/src/display_manager_stub.cpp
@@ -106,7 +106,8 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
         case DisplayManagerMessage::TRANS_ID_SET_ORIENTATION: {
             ScreenId screenId = static_cast<ScreenId>(data.ReadUint64());
             Orientation orientation = static_cast<Orientation>(data.ReadUint32());
-            reply.WriteBool(SetOrientation(screenId, orientation));
+            DMError ret = SetOrientation(screenId, orientation);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_GET_DISPLAY_SNAPSHOT: {
@@ -118,13 +119,15 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
         case DisplayManagerMessage::TRANS_ID_REGISTER_DISPLAY_MANAGER_AGENT: {
             auto agent = iface_cast<IDisplayManagerAgent>(data.ReadRemoteObject());
             auto type = static_cast<DisplayManagerAgentType>(data.ReadUint32());
-            reply.WriteBool(RegisterDisplayManagerAgent(agent, type));
+            DMError ret = RegisterDisplayManagerAgent(agent, type);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_UNREGISTER_DISPLAY_MANAGER_AGENT: {
             auto agent = iface_cast<IDisplayManagerAgent>(data.ReadRemoteObject());
             auto type = static_cast<DisplayManagerAgentType>(data.ReadUint32());
-            reply.WriteBool(UnregisterDisplayManagerAgent(agent, type));
+            DMError ret = UnregisterDisplayManagerAgent(agent, type);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_WAKE_UP_BEGIN: {
@@ -188,8 +191,10 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
                 WLOGE("fail to receive mirror screen in stub. screen:%{public}" PRIu64"", mainScreenId);
                 break;
             }
-            ScreenId result = MakeMirror(mainScreenId, mirrorScreenId);
-            reply.WriteUint64(static_cast<uint64_t>(result));
+            ScreenId screenGroupId = INVALID_SCREEN_ID;
+            DMError ret = MakeMirror(mainScreenId, mirrorScreenId, screenGroupId);
+            reply.WriteInt32(static_cast<int32_t>(ret));
+            reply.WriteUint64(static_cast<uint64_t>(screenGroupId));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_GET_SCREEN_INFO_BY_ID: {
@@ -205,7 +210,9 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
             break;
         }
         case DisplayManagerMessage::TRANS_ID_GET_ALL_SCREEN_INFOS: {
-            std::vector<sptr<ScreenInfo>> screenInfos = GetAllScreenInfos();
+            std::vector<sptr<ScreenInfo>> screenInfos;
+            DMError ret  = GetAllScreenInfos(screenInfos);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             if (!MarshallingHelper::MarshallingVectorParcelableObj<ScreenInfo>(reply, screenInfos)) {
                 WLOGE("fail to marshalling screenInfos in stub.");
             }
@@ -229,8 +236,10 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
                 WLOGE("fail to receive startPoint in stub.");
                 break;
             }
-            ScreenId result = MakeExpand(screenId, startPoint);
-            reply.WriteUint64(static_cast<uint64_t>(result));
+            ScreenId screenGroupId = INVALID_SCREEN_ID;
+            DMError ret = MakeExpand(screenId, startPoint, screenGroupId);
+            reply.WriteInt32(static_cast<int32_t>(ret));
+            reply.WriteUint64(static_cast<uint64_t>(screenGroupId));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_REMOVE_VIRTUAL_SCREEN_FROM_SCREEN_GROUP: {
@@ -245,15 +254,15 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
         case DisplayManagerMessage::TRANS_ID_SET_SCREEN_ACTIVE_MODE: {
             ScreenId screenId = static_cast<ScreenId>(data.ReadUint64());
             uint32_t modeId = data.ReadUint32();
-            bool res = SetScreenActiveMode(screenId, modeId);
-            reply.WriteBool(res);
+            DMError ret = SetScreenActiveMode(screenId, modeId);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_SET_VIRTUAL_PIXEL_RATIO: {
             ScreenId screenId = static_cast<ScreenId>(data.ReadUint64());
             float virtualPixelRatio = data.ReadFloat();
-            bool res = SetVirtualPixelRatio(screenId, virtualPixelRatio);
-            reply.WriteBool(res);
+            DMError ret = SetVirtualPixelRatio(screenId, virtualPixelRatio);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             break;
         }
         case DisplayManagerMessage::TRANS_ID_SCREEN_GET_SUPPORTED_COLOR_GAMUTS: {
@@ -314,7 +323,9 @@ int32_t DisplayManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data,
             break;
         }
         case DisplayManagerMessage::TRANS_ID_IS_SCREEN_ROTATION_LOCKED: {
-            bool isLocked = IsScreenRotationLocked();
+            bool isLocked = false;
+            DMError ret = IsScreenRotationLocked(isLocked);
+            reply.WriteInt32(static_cast<int32_t>(ret));
             reply.WriteBool(isLocked);
             break;
         }
diff --git a/interfaces/innerkits/dm/display_manager.h b/interfaces/innerkits/dm/display_manager.h
index d1d93a7d..71042758 100644
--- a/interfaces/innerkits/dm/display_manager.h
+++ b/interfaces/innerkits/dm/display_manager.h
@@ -66,12 +66,12 @@ public:
     bool Freeze(std::vector<DisplayId> displayIds);
     bool Unfreeze(std::vector<DisplayId> displayIds);
 
-    bool RegisterDisplayListener(sptr<IDisplayListener> listener);
-    bool UnregisterDisplayListener(sptr<IDisplayListener> listener);
-    bool RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
-    bool UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
-    bool RegisterScreenshotListener(sptr<IScreenshotListener> listener);
-    bool UnregisterScreenshotListener(sptr<IScreenshotListener> listener);
+    DMError RegisterDisplayListener(sptr<IDisplayListener> listener);
+    DMError UnregisterDisplayListener(sptr<IDisplayListener> listener);
+    DMError RegisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
+    DMError UnregisterDisplayPowerEventListener(sptr<IDisplayPowerEventListener> listener);
+    DMError RegisterScreenshotListener(sptr<IScreenshotListener> listener);
+    DMError UnregisterScreenshotListener(sptr<IScreenshotListener> listener);
 
     constexpr static int32_t MAX_RESOLUTION_SIZE_SCREENSHOT = 3840; // max resolution, 4K
 
diff --git a/interfaces/innerkits/dm/dm_common.h b/interfaces/innerkits/dm/dm_common.h
index a3e8a6b9..78d73485 100644
--- a/interfaces/innerkits/dm/dm_common.h
+++ b/interfaces/innerkits/dm/dm_common.h
@@ -73,12 +73,14 @@ enum class DMError : int32_t {
     DM_ERROR_UNREGISTER_AGENT_FAILED = 190,
     DM_ERROR_INVALID_CALLING = 200,
     DM_ERROR_INVALID_PERMISSION = 201,
+    DM_ERROR_NOT_SYSTEM_APP = 202,
     DM_ERROR_UNKNOWN = -1,
 };
 
 enum class DmErrorCode : int32_t {
     DM_OK = 0,
     DM_ERROR_NO_PERMISSION = 201,
+    DM_ERROR_NOT_SYSTEM_APP = 202,
     DM_ERROR_INVALID_PARAM = 401,
     DM_ERROR_DEVICE_NOT_SUPPORT = 801,
     DM_ERROR_INVALID_SCREEN = 1400001,
@@ -101,6 +103,7 @@ const std::map<DMError, DmErrorCode> DM_JS_TO_ERROR_CODE_MAP {
     {DMError::DM_ERROR_RENDER_SERVICE_FAILED,           DmErrorCode::DM_ERROR_SYSTEM_INNORMAL       },
     {DMError::DM_ERROR_UNREGISTER_AGENT_FAILED,         DmErrorCode::DM_ERROR_SYSTEM_INNORMAL       },
     {DMError::DM_ERROR_INVALID_CALLING,                 DmErrorCode::DM_ERROR_INVALID_CALLING       },
+    {DMError::DM_ERROR_NOT_SYSTEM_APP,                  DmErrorCode::DM_ERROR_NOT_SYSTEM_APP        },
     {DMError::DM_ERROR_UNKNOWN,                         DmErrorCode::DM_ERROR_SYSTEM_INNORMAL       },
 };
 
diff --git a/interfaces/innerkits/dm/screen.h b/interfaces/innerkits/dm/screen.h
index ec29cff2..e748e8a2 100644
--- a/interfaces/innerkits/dm/screen.h
+++ b/interfaces/innerkits/dm/screen.h
@@ -78,9 +78,9 @@ public:
     ScreenId GetParentId() const;
     uint32_t GetModeId() const;
     std::vector<sptr<SupportedScreenModes>> GetSupportedModes() const;
-    bool SetScreenActiveMode(uint32_t modeId);
-    bool SetOrientation(Orientation orientation) const;
-    bool SetDensityDpi(uint32_t dpi) const;
+    DMError SetScreenActiveMode(uint32_t modeId);
+    DMError SetOrientation(Orientation orientation) const;
+    DMError SetDensityDpi(uint32_t dpi) const;
     sptr<ScreenInfo> GetScreenInfo() const;
 
     // colorspace, gamut
diff --git a/interfaces/innerkits/dm/screen_manager.h b/interfaces/innerkits/dm/screen_manager.h
index 2c1b83c0..9f082779 100644
--- a/interfaces/innerkits/dm/screen_manager.h
+++ b/interfaces/innerkits/dm/screen_manager.h
@@ -52,10 +52,10 @@ public:
 
     sptr<Screen> GetScreenById(ScreenId screenId);
     sptr<ScreenGroup> GetScreenGroup(ScreenId groupId);
-    std::vector<sptr<Screen>> GetAllScreens();
+    DMError GetAllScreens(std::vector<sptr<Screen>>& screens);
 
-    ScreenId MakeExpand(const std::vector<ExpandOption>& options);
-    ScreenId MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId);
+    DMError MakeExpand(const std::vector<ExpandOption>& options, ScreenId& screenGroupId);
+    DMError MakeMirror(ScreenId mainScreenId, std::vector<ScreenId> mirrorScreenId, ScreenId& screenGroupId);
     DMError RemoveVirtualScreenFromGroup(std::vector<ScreenId> screens);
     ScreenId CreateVirtualScreen(VirtualScreenOption option);
     DMError DestroyVirtualScreen(ScreenId screenId);
@@ -63,14 +63,14 @@ public:
     bool SetScreenPowerForAll(ScreenPowerState state, PowerStateChangeReason reason);
     ScreenPowerState GetScreenPower(ScreenId screenId);
     DMError SetScreenRotationLocked(bool isLocked);
-    bool IsScreenRotationLocked();
+    DMError IsScreenRotationLocked(bool& isLocked);
 
-    bool RegisterScreenListener(sptr<IScreenListener> listener);
-    bool UnregisterScreenListener(sptr<IScreenListener> listener);
-    bool RegisterScreenGroupListener(sptr<IScreenGroupListener> listener);
-    bool UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener);
-    bool RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
-    bool UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
+    DMError RegisterScreenListener(sptr<IScreenListener> listener);
+    DMError UnregisterScreenListener(sptr<IScreenListener> listener);
+    DMError RegisterScreenGroupListener(sptr<IScreenGroupListener> listener);
+    DMError UnregisterScreenGroupListener(sptr<IScreenGroupListener> listener);
+    DMError RegisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
+    DMError UnregisterVirtualScreenGroupListener(sptr<IVirtualScreenGroupListener> listener);
 private:
     ScreenManager();
     ~ScreenManager();
diff --git a/interfaces/innerkits/wm/window.h b/interfaces/innerkits/wm/window.h
index c64c669a..f814407c 100644
--- a/interfaces/innerkits/wm/window.h
+++ b/interfaces/innerkits/wm/window.h
@@ -152,7 +152,9 @@ public:
     virtual void OnDialogDeathRecipient() const = 0;
 };
 
+static WMError DefaultCreateErrCode = WMError::WM_OK;
 class Window : public RefBase {
+private:
 public:
     /**
      * @brief create window, include main_window/sub_window/system_window
@@ -163,7 +165,8 @@ public:
      * @return sptr<Window> If create window success,return window instance;Otherwise, return nullptr
      */
     static sptr<Window> Create(const std::string& windowName,
-        sptr<WindowOption>& option, const std::shared_ptr<AbilityRuntime::Context>& context = nullptr);
+        sptr<WindowOption>& option, const std::shared_ptr<AbilityRuntime::Context>& context = nullptr,
+        WMError& errCode = DefaultCreateErrCode);
     /**
      * @brief find window by windowName
      *
@@ -253,8 +256,8 @@ public:
      * @return WMError
      */
     virtual WMError SetWindowMode(WindowMode mode) = 0;
-    virtual void SetAlpha(float alpha) = 0;
-    virtual void SetTransform(const Transform& trans) = 0;
+    virtual WMError SetAlpha(float alpha) = 0;
+    virtual WMError SetTransform(const Transform& trans) = 0;
     virtual const Transform& GetTransform() const = 0;
     virtual WMError AddWindowFlag(WindowFlag flag) = 0;
     virtual WMError RemoveWindowFlag(WindowFlag flag) = 0;
@@ -329,18 +332,18 @@ public:
     virtual WMError SetBrightness(float brightness) = 0;
     virtual float GetBrightness() const = 0;
     virtual WMError SetCallingWindow(uint32_t windowId) = 0;
-    virtual void SetPrivacyMode(bool isPrivacyMode) = 0;
+    virtual WMError SetPrivacyMode(bool isPrivacyMode) = 0;
     virtual bool IsPrivacyMode() const = 0;
     virtual void SetSystemPrivacyMode(bool isSystemPrivacyMode) = 0;
     virtual WMError BindDialogTarget(sptr<IRemoteObject> targetToken) = 0;
-    virtual void SetSnapshotSkip(bool isSkip) = 0;
+    virtual WMError SetSnapshotSkip(bool isSkip) = 0;
 
     // window effect
     virtual WMError SetCornerRadius(float cornerRadius) = 0;
     virtual WMError SetShadowRadius(float radius) = 0;
     virtual WMError SetShadowColor(std::string color) = 0;
-    virtual void SetShadowOffsetX(float offsetX) = 0;
-    virtual void SetShadowOffsetY(float offsetY) = 0;
+    virtual WMError SetShadowOffsetX(float offsetX) = 0;
+    virtual WMError SetShadowOffsetY(float offsetY) = 0;
     virtual WMError SetBlur(float radius) = 0;
     virtual WMError SetBackdropBlur(float radius) = 0;
     virtual WMError SetBackdropBlurStyle(WindowBlurStyle blurStyle) = 0;
@@ -358,26 +361,26 @@ public:
      *
      * @param listener
      */
-    virtual bool RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) = 0;
-    virtual bool RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) = 0;
-    virtual bool UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) = 0;
-    virtual bool UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) = 0;
-    virtual bool RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) = 0;
-    virtual bool UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) = 0;
-    virtual bool RegisterDragListener(const sptr<IWindowDragListener>& listener) = 0;
-    virtual bool UnregisterDragListener(const sptr<IWindowDragListener>& listener) = 0;
-    virtual bool RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) = 0;
-    virtual bool UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) = 0;
+    virtual WMError RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) = 0;
+    virtual WMError UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) = 0;
+    virtual WMError RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) = 0;
+    virtual WMError UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) = 0;
+    virtual WMError RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) = 0;
+    virtual WMError UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) = 0;
+    virtual WMError RegisterDragListener(const sptr<IWindowDragListener>& listener) = 0;
+    virtual WMError UnregisterDragListener(const sptr<IWindowDragListener>& listener) = 0;
+    virtual WMError RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) = 0;
+    virtual WMError UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) = 0;
     virtual void RegisterWindowDestroyedListener(const NotifyNativeWinDestroyFunc& func) = 0;
-    virtual bool RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) = 0;
-    virtual bool UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) = 0;
-    virtual bool RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) = 0;
-    virtual bool UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) = 0;
-    virtual bool RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener) = 0;
-    virtual bool RegisterScreenshotListener(const sptr<IScreenshotListener>& listener) = 0;
-    virtual bool UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener) = 0;
-    virtual bool RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) = 0;
-    virtual bool UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) = 0;
+    virtual WMError RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) = 0;
+    virtual WMError UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) = 0;
+    virtual WMError RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) = 0;
+    virtual WMError UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) = 0;
+    virtual WMError RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener) = 0;
+    virtual WMError RegisterScreenshotListener(const sptr<IScreenshotListener>& listener) = 0;
+    virtual WMError UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener) = 0;
+    virtual WMError RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) = 0;
+    virtual WMError UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) = 0;
     virtual void RegisterDialogDeathRecipientListener(const sptr<IDialogDeathRecipientListener>& listener) = 0;
     virtual void UnregisterDialogDeathRecipientListener(const sptr<IDialogDeathRecipientListener>& listener) = 0;
     virtual void NotifyTouchDialogTarget() = 0;
@@ -411,7 +414,7 @@ public:
      * @brief disable main window decoration. It must be callled before loadContent.
      *
      */
-    virtual void DisableAppWindowDecor() = 0;
+    virtual WMError DisableAppWindowDecor() = 0;
     /**
      * @brief return window decoration is enabled. It is called by ACE
      *
diff --git a/interfaces/innerkits/wm/window_manager.h b/interfaces/innerkits/wm/window_manager.h
index b42f12a7..ef71baaa 100644
--- a/interfaces/innerkits/wm/window_manager.h
+++ b/interfaces/innerkits/wm/window_manager.h
@@ -121,17 +121,17 @@ WM_DECLARE_SINGLE_INSTANCE_BASE(WindowManager);
 friend class WindowManagerAgent;
 friend class WMSDeathRecipient;
 public:
-    bool RegisterFocusChangedListener(const sptr<IFocusChangedListener>& listener);
-    bool UnregisterFocusChangedListener(const sptr<IFocusChangedListener>& listener);
-    bool RegisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener);
-    bool UnregisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener);
-    bool RegisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener);
-    bool UnregisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener);
-    bool RegisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener);
-    bool UnregisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener);
-    bool RegisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener);
-    bool UnregisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener);
-    void MinimizeAllAppWindows(DisplayId displayId);
+    WMError RegisterFocusChangedListener(const sptr<IFocusChangedListener>& listener);
+    WMError UnregisterFocusChangedListener(const sptr<IFocusChangedListener>& listener);
+    WMError RegisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener);
+    WMError UnregisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener);
+    WMError RegisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener);
+    WMError UnregisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener);
+    WMError RegisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener);
+    WMError UnregisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener);
+    WMError RegisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener);
+    WMError UnregisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener);
+    WMError MinimizeAllAppWindows(DisplayId displayId);
     WMError ToggleShownStateForAllAppWindows();
     WMError SetWindowLayoutMode(WindowLayoutMode mode);
     WMError GetAccessibilityWindowInfo(std::vector<sptr<AccessibilityWindowInfo>>& infos) const;
diff --git a/interfaces/innerkits/wm/wm_common.h b/interfaces/innerkits/wm/wm_common.h
index 28e2dce4..23cbe4b6 100644
--- a/interfaces/innerkits/wm/wm_common.h
+++ b/interfaces/innerkits/wm/wm_common.h
@@ -124,6 +124,7 @@ enum class WMError : int32_t {
     WM_ERROR_INVALID_WINDOW_MODE_OR_SIZE,
     WM_ERROR_INVALID_OPERATION,
     WM_ERROR_INVALID_PERMISSION,
+    WM_ERROR_NOT_SYSTEM_APP,
     WM_ERROR_NO_REMOTE_ANIMATION,
 
     WM_ERROR_DEVICE_NOT_SUPPORT = 801, // the value do not change.It is defined on all system
@@ -141,6 +142,7 @@ enum class WMError : int32_t {
 enum class WmErrorCode : int32_t {
     WM_OK = 0,
     WM_ERROR_NO_PERMISSION = 201,
+    WM_ERROR_NOT_SYSTEM_APP = 202,
     WM_ERROR_INVALID_PARAM = 401,
     WM_ERROR_DEVICE_NOT_SUPPORT = 801,
     WM_ERROR_REPEAT_OPERATION = 1300001,
@@ -160,6 +162,7 @@ const std::map<WMError, WmErrorCode> WM_JS_TO_ERROR_CODE_MAP {
     {WMError::WM_ERROR_INVALID_OPERATION,              WmErrorCode::WM_ERROR_STATE_ABNORMALLY     },
     {WMError::WM_ERROR_INVALID_PARAM,                  WmErrorCode::WM_ERROR_INVALID_PARAM        },
     {WMError::WM_ERROR_INVALID_PERMISSION,             WmErrorCode::WM_ERROR_NO_PERMISSION        },
+    {WMError::WM_ERROR_NOT_SYSTEM_APP,                 WmErrorCode::WM_ERROR_NOT_SYSTEM_APP       },
     {WMError::WM_ERROR_INVALID_TYPE,                   WmErrorCode::WM_ERROR_STATE_ABNORMALLY     },
     {WMError::WM_ERROR_INVALID_WINDOW,                 WmErrorCode::WM_ERROR_STATE_ABNORMALLY     },
     {WMError::WM_ERROR_INVALID_WINDOW_MODE_OR_SIZE,    WmErrorCode::WM_ERROR_STATE_ABNORMALLY     },
diff --git a/interfaces/kits/napi/screen_runtime/napi/js_screen.cpp b/interfaces/kits/napi/screen_runtime/napi/js_screen.cpp
index 4c7b818c..4d069c52 100644
--- a/interfaces/kits/napi/screen_runtime/napi/js_screen.cpp
+++ b/interfaces/kits/napi/screen_runtime/napi/js_screen.cpp
@@ -96,12 +96,12 @@ NativeValue* JsScreen::OnSetOrientation(NativeEngine& engine, NativeCallbackInfo
 
     AsyncTask::CompleteCallback complete =
         [=](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            bool res = screen_->SetOrientation(orientation);
-            if (res) {
+            DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(screen_->SetOrientation(orientation));
+            if (ret == DmErrorCode::DM_OK) {
                 task.Resolve(engine, engine.CreateUndefined());
                 WLOGFI("OnSetOrientation success");
             } else {
-                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_SYSTEM_INNORMAL),
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(ret),
                                                   "JsScreen::OnSetOrientation failed."));
                 WLOGFE("OnSetOrientation failed");
             }
@@ -147,12 +147,12 @@ NativeValue* JsScreen::OnSetScreenActiveMode(NativeEngine& engine, NativeCallbac
 
     AsyncTask::CompleteCallback complete =
         [=](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            bool res = screen_->SetScreenActiveMode(modeId);
-            if (res) {
+            DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(screen_->SetScreenActiveMode(modeId));
+            if (ret == DmErrorCode::DM_OK) {
                 task.Resolve(engine, engine.CreateUndefined());
                 WLOGFI("OnSetScreenActiveMode success");
             } else {
-                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_SYSTEM_INNORMAL),
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(ret),
                                                 "JsScreen::OnSetScreenActiveMode failed."));
                 WLOGFE("OnSetScreenActiveMode failed");
             }
@@ -197,12 +197,12 @@ NativeValue* JsScreen::OnSetDensityDpi(NativeEngine& engine, NativeCallbackInfo&
 
     AsyncTask::CompleteCallback complete =
         [=](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            bool res = screen_->SetDensityDpi(densityDpi);
-            if (res) {
+            DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(screen_->SetDensityDpi(densityDpi));
+            if (ret == DmErrorCode::DM_OK) {
                 task.Resolve(engine, engine.CreateUndefined());
                 WLOGFI("OnSetDensityDpi success");
             } else {
-                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_SYSTEM_INNORMAL),
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(ret),
                                                 "JsScreen::OnSetDensityDpi failed."));
                 WLOGFE("OnSetDensityDpi failed");
             }
diff --git a/interfaces/kits/napi/screen_runtime/napi/js_screen_manager.cpp b/interfaces/kits/napi/screen_runtime/napi/js_screen_manager.cpp
index 476275f3..1ffaf19e 100644
--- a/interfaces/kits/napi/screen_runtime/napi/js_screen_manager.cpp
+++ b/interfaces/kits/napi/screen_runtime/napi/js_screen_manager.cpp
@@ -60,7 +60,7 @@ static NativeValue* GetAllScreens(NativeEngine* engine, NativeCallbackInfo* info
 static NativeValue* RegisterScreenManagerCallback(NativeEngine* engine, NativeCallbackInfo* info)
 {
     JsScreenManager* me = CheckParamsAndGetThis<JsScreenManager>(engine, info);
-    return (me != nullptr) ? me->OnRegisterScreenMangerCallback(*engine, *info) : nullptr;
+    return (me != nullptr) ? me->OnRegisterScreenManagerCallback(*engine, *info) : nullptr;
 }
 
 static NativeValue* UnregisterScreenMangerCallback(NativeEngine* engine, NativeCallbackInfo* info)
@@ -119,8 +119,12 @@ NativeValue* OnGetAllScreens(NativeEngine& engine, NativeCallbackInfo& info)
     WLOGFI("OnGetAllScreens is called");
     AsyncTask::CompleteCallback complete =
         [this](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            std::vector<sptr<Screen>> screens = SingletonContainer::Get<ScreenManager>().GetAllScreens();
-            if (!screens.empty()) {
+            std::vector<sptr<Screen>> screens;
+            auto res = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().GetAllScreens(screens));
+            if (res != DmErrorCode::DM_OK) {
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(res),
+                    "JsScreenManager::OnGetAllScreens failed."));
+            } else if (!screens.empty()) {
                 task.Resolve(engine, CreateJsScreenVectorObject(engine, screens));
                 WLOGFI("JsScreenManager::OnGetAllScreens success");
             } else {
@@ -174,37 +178,41 @@ bool IfCallbackRegistered(const std::string& type, NativeValue* jsListenerObject
     return false;
 }
 
-void RegisterScreenListenerWithType(NativeEngine& engine, const std::string& type, NativeValue* value)
+DmErrorCode RegisterScreenListenerWithType(NativeEngine& engine, const std::string& type, NativeValue* value)
 {
     if (IfCallbackRegistered(type, value)) {
         WLOGFE("JsScreenManager::RegisterScreenListenerWithType callback already registered!");
-        return;
+        return DmErrorCode::DM_ERROR_INVALID_CALLING;
     }
     std::unique_ptr<NativeReference> callbackRef;
     callbackRef.reset(engine.CreateReference(value, 1));
     sptr<JsScreenListener> screenListener = new(std::nothrow) JsScreenListener(&engine);
     if (screenListener == nullptr) {
         WLOGFE("screenListener is nullptr");
-        return;
+        return DmErrorCode::DM_ERROR_INVALID_SCREEN;
     }
     if (type == EVENT_CONNECT || type == EVENT_DISCONNECT || type == EVENT_CHANGE) {
-        SingletonContainer::Get<ScreenManager>().RegisterScreenListener(screenListener);
+        DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().RegisterScreenListener(screenListener));
+        if (ret != DmErrorCode::DM_OK) {
+            return ret;
+        }
         WLOGFI("JsScreenManager::RegisterScreenListenerWithType success");
     } else {
         WLOGFE("JsScreenManager::RegisterScreenListenerWithType failed method: %{public}s not support!",
             type.c_str());
-        return;
+        return DmErrorCode::DM_ERROR_INVALID_CALLING;
     }
     screenListener->AddCallback(type, value);
     jsCbMap_[type][std::move(callbackRef)] = screenListener;
+    return DmErrorCode::DM_OK;
 }
 
-void UnregisterAllScreenListenerWithType(const std::string& type)
+DmErrorCode UnregisterAllScreenListenerWithType(const std::string& type)
 {
     if (jsCbMap_.empty() || jsCbMap_.find(type) == jsCbMap_.end()) {
-        WLOGFI("JsScreenManager::UnregisterAllScreenListenerWithType methodName %{public}s not registered!",
+        WLOGFE("JsScreenManager::UnregisterAllScreenListenerWithType methodName %{public}s not registered!",
             type.c_str());
-        return;
+        return DmErrorCode::DM_ERROR_INVALID_CALLING;
     }
     for (auto it = jsCbMap_[type].begin(); it != jsCbMap_[type].end();) {
         it->second->RemoveAllCallback();
@@ -216,18 +224,19 @@ void UnregisterAllScreenListenerWithType(const std::string& type)
         jsCbMap_[type].erase(it++);
     }
     jsCbMap_.erase(type);
+    return DmErrorCode::DM_OK;
 }
 
-void UnRegisterScreenListenerWithType(const std::string& type, NativeValue* value)
+DmErrorCode UnRegisterScreenListenerWithType(const std::string& type, NativeValue* value)
 {
     if (jsCbMap_.empty() || jsCbMap_.find(type) == jsCbMap_.end()) {
         WLOGFI("JsScreenManager::UnRegisterScreenListenerWithType methodName %{public}s not registered!",
             type.c_str());
-        return;
+        return DmErrorCode::DM_OK;
     }
     if (value == nullptr) {
         WLOGFE("JsScreenManager::UnRegisterScreenListenerWithType value is nullptr");
-        return;
+        return DmErrorCode::DM_ERROR_INVALID_SCREEN;
     }
     for (auto it = jsCbMap_[type].begin(); it != jsCbMap_[type].end();) {
         if (value->StrictEquals(it->first->Get())) {
@@ -246,11 +255,12 @@ void UnRegisterScreenListenerWithType(const std::string& type, NativeValue* valu
     if (jsCbMap_[type].empty()) {
         jsCbMap_.erase(type);
     }
+    return DmErrorCode::DM_OK;
 }
 
-NativeValue* OnRegisterScreenMangerCallback(NativeEngine& engine, NativeCallbackInfo& info)
+NativeValue* OnRegisterScreenManagerCallback(NativeEngine& engine, NativeCallbackInfo& info)
 {
-    WLOGFI("JsScreenManager::OnRegisterScreenMangerCallback is called");
+    WLOGFI("JsScreenManager::OnRegisterScreenManagerCallback is called");
     if (info.argc < ARGC_TWO) {
         WLOGFE("Params not match");
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_PARAM)));
@@ -264,17 +274,21 @@ NativeValue* OnRegisterScreenMangerCallback(NativeEngine& engine, NativeCallback
     }
     NativeValue* value = info.argv[INDEX_ONE];
     if (value == nullptr) {
-        WLOGFI("JsScreenManager::OnRegisterScreenMangerCallback info->argv[1] is nullptr");
+        WLOGFI("JsScreenManager::OnRegisterScreenManagerCallback info->argv[1] is nullptr");
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
     if (!value->IsCallable()) {
-        WLOGFI("JsScreenManager::OnRegisterScreenMangerCallback info->argv[1] is not callable");
+        WLOGFI("JsScreenManager::OnRegisterScreenManagerCallback info->argv[1] is not callable");
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
     std::lock_guard<std::mutex> lock(mtx_);
-    RegisterScreenListenerWithType(engine, cbType, value);
+    DmErrorCode ret = RegisterScreenListenerWithType(engine, cbType, value);
+    if (ret != DmErrorCode::DM_OK) {
+        WLOGFE("JsScreenManager::OnRegisterScreenManagerCallback failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+    }
     return engine.CreateUndefined();
 }
 
@@ -338,12 +352,13 @@ NativeValue* OnMakeMirror(NativeEngine& engine, NativeCallbackInfo& info)
 
     AsyncTask::CompleteCallback complete =
         [mainScreenId, screenIds](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            ScreenId id = SingletonContainer::Get<ScreenManager>().MakeMirror(mainScreenId, screenIds);
-            if (id != SCREEN_ID_INVALID) {
-                task.Resolve(engine, CreateJsValue(engine, static_cast<uint32_t>(id)));
+            ScreenId screenGroupId = INVALID_SCREEN_ID;
+            DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().MakeMirror(mainScreenId, screenIds, screenGroupId));
+            if (ret == DmErrorCode::DM_OK) {
+                task.Resolve(engine, CreateJsValue(engine, static_cast<uint32_t>(screenGroupId)));
             } else {
                 task.Reject(engine, CreateJsError(engine,
-                    static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_SCREEN),
+                    static_cast<int32_t>(ret),
                     "JsScreenManager::OnMakeMirror failed."));
             }
         };
@@ -389,13 +404,14 @@ NativeValue* OnMakeExpand(NativeEngine& engine, NativeCallbackInfo& info)
 
     AsyncTask::CompleteCallback complete =
         [options](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            ScreenId id = SingletonContainer::Get<ScreenManager>().MakeExpand(options);
-            if (id != SCREEN_ID_INVALID) {
-                task.Resolve(engine, CreateJsValue(engine, static_cast<uint32_t>(id)));
+            ScreenId screenGroupId = INVALID_SCREEN_ID;
+            DmErrorCode ret = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().MakeExpand(options, screenGroupId));
+            if (ret == DmErrorCode::DM_OK) {
+                task.Resolve(engine, CreateJsValue(engine, static_cast<uint32_t>(screenGroupId)));
                 WLOGFI("MakeExpand success");
             } else {
                 task.Reject(engine, CreateJsError(engine,
-                    static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_SCREEN),
+                    static_cast<int32_t>(ret),
                     "JsScreenManager::OnMakeExpand failed."));
                 WLOGFE("MakeExpand failed");
             }
@@ -633,8 +649,16 @@ NativeValue* OnIsScreenRotationLocked(NativeEngine& engine, NativeCallbackInfo&
     WLOGFI("OnIsScreenRotationLocked is called");
     AsyncTask::CompleteCallback complete =
         [](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            bool isLocked = SingletonContainer::Get<ScreenManager>().IsScreenRotationLocked();
-            task.Resolve(engine, CreateJsValue(engine, isLocked));
+            bool isLocked = false;
+            auto res = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().IsScreenRotationLocked(isLocked));
+            if (res == DmErrorCode::DM_OK) {
+                task.Resolve(engine, CreateJsValue(engine, isLocked));
+                WLOGFI("OnIsScreenRotationLocked success");
+            } else {
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(res),
+                                                  "JsScreenManager::OnIsScreenRotationLocked failed."));
+                WLOGFE("OnIsScreenRotationLocked failed");
+            }
         };
     NativeValue* lastParam = nullptr;
     if (info.argc >= ARGC_ONE && info.argv[ARGC_ONE - 1] != nullptr &&
@@ -673,8 +697,15 @@ NativeValue* OnSetScreenRotationLocked(NativeEngine& engine, NativeCallbackInfo&
 
     AsyncTask::CompleteCallback complete =
         [isLocked](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            SingletonContainer::Get<ScreenManager>().SetScreenRotationLocked(isLocked);
-            task.Resolve(engine, engine.CreateUndefined());
+            auto res = DM_JS_TO_ERROR_CODE_MAP.at(SingletonContainer::Get<ScreenManager>().SetScreenRotationLocked(isLocked));
+            if (res == DmErrorCode::DM_OK) {
+                task.Resolve(engine, engine.CreateUndefined());
+                WLOGFI("OnSetScreenRotationLocked success");
+            } else {
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(res),
+                                                  "JsScreenManager::OnSetScreenRotationLocked failed."));
+                WLOGFE("OnSetScreenRotationLocked failed");
+            }
         };
     NativeValue* lastParam = (info.argc <= ARGC_ONE) ? nullptr :
         ((info.argv[ARGC_TWO - 1] != nullptr && info.argv[ARGC_TWO - 1]->TypeOf() == NATIVE_FUNCTION) ?
@@ -730,6 +761,8 @@ NativeValue* InitDisplayErrorCode(NativeEngine* engine)
 
     object->SetProperty("DM_ERROR_NO_PERMISSION",
         CreateJsValue(*engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_NO_PERMISSION)));
+    object->SetProperty("DM_ERROR_NOT_SYSTEM_APP",
+        CreateJsValue(*engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_NOT_SYSTEM_APP)));
     object->SetProperty("DM_ERROR_INVALID_PARAM",
         CreateJsValue(*engine, static_cast<int32_t>(DmErrorCode::DM_ERROR_INVALID_PARAM)));
     object->SetProperty("DM_ERROR_DEVICE_NOT_SUPPORT",
diff --git a/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.cpp b/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.cpp
index 6bc4a0e8..3523dcf5 100644
--- a/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.cpp
+++ b/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.cpp
@@ -86,7 +86,7 @@ NativeValue* JsWindowManager::ToggleShownStateForAllAppWindows(NativeEngine* eng
 NativeValue* JsWindowManager::RegisterWindowManagerCallback(NativeEngine* engine, NativeCallbackInfo* info)
 {
     JsWindowManager* me = CheckParamsAndGetThis<JsWindowManager>(engine, info);
-    return (me != nullptr) ? me->OnRegisterWindowMangerCallback(*engine, *info) : nullptr;
+    return (me != nullptr) ? me->OnRegisterWindowManagerCallback(*engine, *info) : nullptr;
 }
 
 NativeValue* JsWindowManager::UnregisterWindowMangerCallback(NativeEngine* engine, NativeCallbackInfo* info)
@@ -222,13 +222,13 @@ static void CreateNewSystemWindowTask(void* contextPtr, sptr<WindowOption> windo
             }
         }
     }
-
-    sptr<Window> window = Window::Create(windowOption->GetWindowName(), windowOption, context->lock());
-    if (window != nullptr) {
+    WMError errCode = WMError::WM_OK;
+    sptr<Window> window = Window::Create(windowOption->GetWindowName(), windowOption, context->lock(), errCode);
+    if (window != nullptr && errCode == WMError::WM_OK) {
         task.Resolve(engine, CreateJsWindowObject(engine, window));
     } else {
         WLOGFE("[NAPI]Create window failed");
-        int32_t err = static_cast<int32_t>(WmErrorCode::WM_ERROR_STATE_ABNORMALLY);
+        int32_t err = static_cast<int32_t>(errCode);
         task.Reject(engine, CreateJsError(engine, err, "Create window failed"));
     }
 }
@@ -588,9 +588,14 @@ NativeValue* JsWindowManager::OnMinimizeAll(NativeEngine& engine, NativeCallback
     WLOGFI("[NAPI]Display id = %{public}" PRIu64", err = %{public}d", static_cast<uint64_t>(displayId), errCode);
     AsyncTask::CompleteCallback complete =
         [=](NativeEngine& engine, AsyncTask& task, int32_t status) {
-            SingletonContainer::Get<WindowManager>().MinimizeAllAppWindows(static_cast<uint64_t>(displayId));
-            task.Resolve(engine, engine.CreateUndefined());
-            WLOGFI("[NAPI]OnMinimizeAll success");
+            WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(
+                SingletonContainer::Get<WindowManager>().MinimizeAllAppWindows(static_cast<uint64_t>(displayId)));
+            if (ret == WmErrorCode::WM_OK) {
+                task.Resolve(engine, engine.CreateUndefined());
+                WLOGFI("[NAPI]OnMinimizeAll success");
+            } else {
+                task.Reject(engine, CreateJsError(engine, static_cast<int32_t>(ret), "OnMinimizeAll failed"));
+            }
         };
     NativeValue* lastParam = (info.argc <= 1) ? nullptr :
         ((info.argv[1] != nullptr && info.argv[1]->TypeOf() == NATIVE_FUNCTION) ?
@@ -624,9 +629,9 @@ NativeValue* JsWindowManager::OnToggleShownStateForAllAppWindows(NativeEngine& e
     return result;
 }
 
-NativeValue* JsWindowManager::OnRegisterWindowMangerCallback(NativeEngine& engine, NativeCallbackInfo& info)
+NativeValue* JsWindowManager::OnRegisterWindowManagerCallback(NativeEngine& engine, NativeCallbackInfo& info)
 {
-    WLOGFD("[NAPI]OnRegisterWindowMangerCallback");
+    WLOGFD("[NAPI]OnRegisterWindowManagerCallback");
     if (info.argc < 2) { // 2: params num
         WLOGFE("[NAPI]Argc is invalid: %{public}zu", info.argc);
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
@@ -645,7 +650,11 @@ NativeValue* JsWindowManager::OnRegisterWindowMangerCallback(NativeEngine& engin
         return engine.CreateUndefined();
     }
 
-    registerManager_->RegisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, engine, value);
+    WmErrorCode ret = registerManager_->RegisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, engine, value);
+    if (ret != WmErrorCode::WM_OK) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Register end, type = %{public}s, callback = %{public}p", cbType.c_str(), value);
     return engine.CreateUndefined();
 }
@@ -666,16 +675,21 @@ NativeValue* JsWindowManager::OnUnregisterWindowManagerCallback(NativeEngine& en
     }
 
     NativeValue* value = nullptr;
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (info.argc == 1) {
-        registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, value);
+        ret = registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, value);
     } else {
         value = info.argv[1];
         if ((value == nullptr) || (!value->IsCallable())) {
-            registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, nullptr);
+            ret = registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, nullptr);
         } else {
-            registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, value);
+            ret = registerManager_->UnregisterListener(nullptr, cbType, CaseType::CASE_WINDOW_MANAGER, value);
         }
     }
+    if (ret != WmErrorCode::WM_OK) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Unregister end, type = %{public}s, callback = %{public}p", cbType.c_str(), value);
     return engine.CreateUndefined();
 }
diff --git a/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.h b/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.h
index b68d21d2..f14a79de 100644
--- a/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.h
+++ b/interfaces/kits/napi/window_runtime/window_manager_napi/js_window_manager.h
@@ -49,7 +49,7 @@ private:
     static NativeValue* OnFindWindowSync(NativeEngine& engine, NativeCallbackInfo& info);
     static NativeValue* OnMinimizeAll(NativeEngine& engine, NativeCallbackInfo& info);
     static NativeValue* OnToggleShownStateForAllAppWindows(NativeEngine& engine, NativeCallbackInfo& info);
-    NativeValue* OnRegisterWindowMangerCallback(NativeEngine& engine, NativeCallbackInfo& info);
+    NativeValue* OnRegisterWindowManagerCallback(NativeEngine& engine, NativeCallbackInfo& info);
     NativeValue* OnUnregisterWindowManagerCallback(NativeEngine& engine, NativeCallbackInfo& info);
     static NativeValue* OnGetTopWindow(NativeEngine& engine, NativeCallbackInfo& info);
     static NativeValue* OnGetLastWindow(NativeEngine& engine, NativeCallbackInfo& info);
diff --git a/interfaces/kits/napi/window_runtime/window_napi/js_window.cpp b/interfaces/kits/napi/window_runtime/window_napi/js_window.cpp
index 6528ff8c..ed0523bd 100644
--- a/interfaces/kits/napi/window_runtime/window_napi/js_window.cpp
+++ b/interfaces/kits/napi/window_runtime/window_napi/js_window.cpp
@@ -39,6 +39,7 @@ using namespace AbilityRuntime;
 namespace {
     constexpr HiviewDFX::HiLogLabel LABEL = {LOG_CORE, HILOG_DOMAIN_WINDOW, "JsWindow"};
     constexpr Rect g_emptyRect = {0, 0, 0, 0};
+    const std::string SET_WINDOW_PRIVACY_MODE_PERMISSION = "ohos.permission.PRIVACY_WINDOW";
 }
 
 static thread_local std::map<std::string, std::shared_ptr<NativeReference>> g_jsWindowMap;
@@ -1084,7 +1085,7 @@ NativeValue* JsWindow::OnSetWindowMode(NativeEngine& engine, NativeCallbackInfo&
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set window mode permission denied!");
-        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_CALLING)));
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_NOT_SYSTEM_APP)));
         return engine.CreateUndefined();
     }
     WmErrorCode errCode = WmErrorCode::WM_OK;
@@ -1220,7 +1221,11 @@ NativeValue* JsWindow::OnRegisterWindowCallback(NativeEngine& engine, NativeCall
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
-    registerManager_->RegisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, engine, value);
+    WmErrorCode ret = registerManager_->RegisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, engine, value);
+    if (ret != WmErrorCode::WM_OK) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Register end, window [%{public}u, %{public}s], type = %{public}s, callback = %{public}p",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str(), cbType.c_str(), value);
     return engine.CreateUndefined();
@@ -1241,17 +1246,21 @@ NativeValue* JsWindow::OnUnregisterWindowCallback(NativeEngine& engine, NativeCa
     }
 
     NativeValue* value = nullptr;
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (info.argc == 1) {
-        registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, value);
+        ret = registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, value);
     } else {
         value = info.argv[1];
         if (value == nullptr || !value->IsCallable()) {
-            registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, nullptr);
+            ret = registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, nullptr);
         } else {
-            registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, value);
+            ret = registerManager_->UnregisterListener(windowToken_, cbType, CaseType::CASE_WINDOW, value);
         }
     }
-
+    if (ret != WmErrorCode::WM_OK) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Unregister end, window [%{public}u, %{public}s], type = %{public}s, callback = %{public}p",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str(), cbType.c_str(), value);
     return engine.CreateUndefined();
@@ -2454,7 +2463,7 @@ NativeValue* JsWindow::OnSetWakeUpScreen(NativeEngine& engine, NativeCallbackInf
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set wake up screen permission denied!");
-        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_CALLING)));
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_NOT_SYSTEM_APP)));
         return engine.CreateUndefined();
     }
     WmErrorCode errCode = WmErrorCode::WM_OK;
@@ -2543,6 +2552,10 @@ NativeValue* JsWindow::OnSetWindowPrivacyMode(NativeEngine& engine, NativeCallba
         WLOGFE("[NAPI]Argc is invalid: %{public}zu", info.argc);
         errCode = WmErrorCode::WM_ERROR_INVALID_PARAM;
     }
+    if (!CheckCallingPermission(SET_WINDOW_PRIVACY_MODE_PERMISSION)) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_NO_PERMISSION)));
+        return engine.CreateUndefined();
+    }
     bool isPrivacyMode = false;
     if (errCode == WmErrorCode::WM_OK) {
         NativeBoolean* nativeVal = ConvertNativeValueTo<NativeBoolean>(info.argv[0]);
@@ -2772,7 +2785,12 @@ NativeValue* JsWindow::OnDisableWindowDecor(NativeEngine& engine, NativeCallback
     if (windowToken_ == nullptr) {
         return engine.CreateUndefined();
     }
-    windowToken_->DisableAppWindowDecor();
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->DisableAppWindowDecor());
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window DisableWindowDecor failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] disable app window decor end",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str());
     return engine.CreateUndefined();
@@ -3071,7 +3089,12 @@ NativeValue* JsWindow::OnSetSnapshotSkip(NativeEngine& engine, NativeCallbackInf
         return engine.CreateUndefined();
     }
 
-    window->SetSnapshotSkip(isSkip);
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(window->SetSnapshotSkip(isSkip));
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window SetSnapshotSkip failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("NAPI [%{public}u, %{public}s] set snapshotSkip end",
         window->GetWindowId(), window->GetWindowName().c_str());
 
@@ -3107,7 +3130,12 @@ NativeValue* JsWindow::OnOpacity(NativeEngine& engine, NativeCallbackInfo& info)
         return engine.CreateUndefined();
     }
     float alpha = static_cast<double>(*nativeVal);
-    windowToken_->SetAlpha(alpha);
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetAlpha(alpha));
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window Opacity failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] Opacity end, alpha = %{public}f",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str(), alpha);
     return engine.CreateUndefined();
@@ -3188,7 +3216,12 @@ NativeValue* JsWindow::OnScale(NativeEngine& engine, NativeCallbackInfo& info)
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
-    windowToken_->SetTransform(trans);
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetTransform(trans));
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window Scale failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] Scale end",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str());
     WLOGFI("[NAPI]scaleX = %{public}f, scaleY = %{public}f, pivotX = %{public}f pivotY = %{public}f",
@@ -3253,7 +3286,12 @@ NativeValue* JsWindow::OnRotate(NativeEngine& engine, NativeCallbackInfo& info)
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
-    windowToken_->SetTransform(trans);
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetTransform(trans));
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window Rotate failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] Rotate end",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str());
     WLOGFI("[NAPI]rotateX = %{public}f, rotateY = %{public}f," \
@@ -3305,7 +3343,12 @@ NativeValue* JsWindow::OnTranslate(NativeEngine& engine, NativeCallbackInfo& inf
         engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
         return engine.CreateUndefined();
     }
-    windowToken_->SetTransform(trans);
+    WmErrorCode ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetTransform(trans));
+    if (ret != WmErrorCode::WM_OK) {
+        WLOGFE("[NAPI]Window Translate failed");
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        return engine.CreateUndefined();
+    }
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] Translate end," \
         "translateX = %{public}f, translateY = %{public}f, translateZ = %{public}f",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str(),
@@ -3313,39 +3356,40 @@ NativeValue* JsWindow::OnTranslate(NativeEngine& engine, NativeCallbackInfo& inf
     return engine.CreateUndefined();
 }
 
-void JsWindow::CreateTransitionController(NativeEngine& engine)
+WmErrorCode JsWindow::CreateTransitionController(NativeEngine& engine)
 {
     if (windowToken_ == nullptr) {
         WLOGFE("[NAPI]windowToken_ is nullptr not match");
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     if (!WindowHelper::IsSystemWindow(windowToken_->GetType())) {
         WLOGFE("[NAPI]CreateTransitionController is not allowed since window is not system window");
-        return;
+        return WmErrorCode::WM_ERROR_INVALID_CALLING;
     }
     NativeValue* objValue = engine.CreateObject();
     auto name = GetWindowName();
     std::shared_ptr<NativeReference> jsWindowObj = FindJsWindowObject(name);
     if (jsWindowObj == nullptr || jsWindowObj->Get() == nullptr) {
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<JsTransitionController> nativeController = new JsTransitionController(
         engine, jsWindowObj, windowToken_);
     NativeObject* object = ConvertNativeValueTo<NativeObject>(objValue);
     if (object == nullptr) {
         WLOGFE("[NAPI]Failed to convert to TransitionController Object");
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     object->SetNativePointer(new wptr<JsTransitionController>(nativeController),
         [](NativeEngine*, void* data, void*) {
             WLOGFE("Finalizer for wptr form native Transition Controller is called");
             delete static_cast<wptr<JsTransitionController>*>(data);
         }, nullptr);
-    windowToken_->RegisterAnimationTransitionController(nativeController);
+    return WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->RegisterAnimationTransitionController(nativeController));
     jsTransControllerObj_.reset(engine.CreateReference(objValue, 1));
     nativeController->SetJsController(jsTransControllerObj_);
     WLOGFI("[NAPI]Window [%{public}u, %{public}s] CreateTransitionController end",
         windowToken_->GetWindowId(), windowToken_->GetWindowName().c_str());
+    return WmErrorCode::WM_OK;
 }
 
 NativeValue* JsWindow::OnGetTransitionController(NativeEngine& engine, NativeCallbackInfo& info)
@@ -3361,7 +3405,11 @@ NativeValue* JsWindow::OnGetTransitionController(NativeEngine& engine, NativeCal
         return engine.CreateUndefined();
     }
     if (jsTransControllerObj_ == nullptr || jsTransControllerObj_->Get() == nullptr) {
-        CreateTransitionController(engine);
+        WmErrorCode ret = CreateTransitionController(engine);
+        if (ret != WmErrorCode::WM_OK) {
+            WLOGFE("[NAPI]Window GetTransitionController failed");
+            engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
+        }
     }
     return jsTransControllerObj_ == nullptr ? nullptr : jsTransControllerObj_->Get();
 }
@@ -3435,28 +3483,28 @@ NativeValue* JsWindow::OnSetShadow(NativeEngine& engine, NativeCallbackInfo& inf
         ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetShadowColor(color));
     }
 
-    if (ret != WmErrorCode::WM_OK) {
-        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
-        return engine.CreateUndefined();
-    }
-
-    if (info.argc >= 3) { // parse the 3rd param: offsetX
+    if ((ret == WmErrorCode::WM_OK) && info.argc >= 3) { // parse the 3rd param: offsetX
         NativeNumber* nativeVal = ConvertNativeValueTo<NativeNumber>(info.argv[2]); // 2: the 3rd param
         if (nativeVal == nullptr) {
             engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
             return engine.CreateUndefined();
         }
-        windowToken_->SetShadowOffsetX(static_cast<double>(*nativeVal));
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetShadowOffsetX(static_cast<double>(*nativeVal)));
     }
 
-    if (info.argc >= 4) { // parse the 4th param: offsetY
+    if ((ret == WmErrorCode::WM_OK) && info.argc >= 4) { // parse the 4th param: offsetY
         NativeNumber* nativeVal = ConvertNativeValueTo<NativeNumber>(info.argv[3]); // 3: the 4th param
         if (nativeVal == nullptr) {
             engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
             return engine.CreateUndefined();
         }
-        windowToken_->SetShadowOffsetY(static_cast<double>(*nativeVal));
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(windowToken_->SetShadowOffsetY(static_cast<double>(*nativeVal)));
+    }
+
+    if (ret != WmErrorCode::WM_OK) {
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(ret)));
     }
+
     return engine.CreateUndefined();
 }
 
diff --git a/interfaces/kits/napi/window_runtime/window_napi/js_window.h b/interfaces/kits/napi/window_runtime/window_napi/js_window.h
index 93be56b2..4ef91a6b 100644
--- a/interfaces/kits/napi/window_runtime/window_napi/js_window.h
+++ b/interfaces/kits/napi/window_runtime/window_napi/js_window.h
@@ -190,7 +190,7 @@ private:
     NativeValue* OnRotate(NativeEngine& engine, NativeCallbackInfo& info);
     NativeValue* OnTranslate(NativeEngine& engine, NativeCallbackInfo& info);
     NativeValue* OnGetTransitionController(NativeEngine& engine, NativeCallbackInfo& info);
-    void CreateTransitionController(NativeEngine& engine);
+    WmErrorCode CreateTransitionController(NativeEngine& engine);
 
     // window effect
     NativeValue* OnSetCornerRadius(NativeEngine& engine, NativeCallbackInfo& info);
diff --git a/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.cpp b/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.cpp
index 5b016fda..ef16b961 100644
--- a/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.cpp
+++ b/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.cpp
@@ -50,156 +50,167 @@ JsWindowRegisterManager::~JsWindowRegisterManager()
 {
 }
 
-bool JsWindowRegisterManager::ProcessWindowChangeRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessWindowChangeRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
         WLOGFE("[NAPI]Window is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IWindowChangeListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterWindowChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterWindowChangeListener(thisListener));
     } else {
-        window->UnregisterWindowChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterWindowChangeListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessSystemAvoidAreaChangeRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessSystemAvoidAreaChangeRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
         WLOGFE("[NAPI]Window is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     if (listener == nullptr) {
         WLOGFE("[NAPI]listener is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     listener->SetIsDeprecatedInterface(true);
     sptr<IAvoidAreaChangedListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterAvoidAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterAvoidAreaChangeListener(thisListener));
     } else {
-        window->UnregisterAvoidAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterAvoidAreaChangeListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessAvoidAreaChangeRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessAvoidAreaChangeRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
         WLOGFE("[NAPI]Window is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IAvoidAreaChangedListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterAvoidAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterAvoidAreaChangeListener(thisListener));
     } else {
-        window->UnregisterAvoidAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterAvoidAreaChangeListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessLifeCycleEventRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessLifeCycleEventRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
         WLOGFE("[NAPI]Window is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IWindowLifeCycle> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterLifeCycleListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterLifeCycleListener(thisListener));
     } else {
-        window->UnregisterLifeCycleListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterLifeCycleListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessOccupiedAreaChangeRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessOccupiedAreaChangeRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
         WLOGFE("[NAPI]Window is nullptr");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IOccupiedAreaChangeListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterOccupiedAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterOccupiedAreaChangeListener(thisListener));
     } else {
-        window->UnregisterOccupiedAreaChangeListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterOccupiedAreaChangeListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessSystemBarChangeRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessSystemBarChangeRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     sptr<ISystemBarChangedListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        SingletonContainer::Get<WindowManager>().RegisterSystemBarChangedListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(
+            SingletonContainer::Get<WindowManager>().RegisterSystemBarChangedListener(thisListener));
     } else {
-        SingletonContainer::Get<WindowManager>().UnregisterSystemBarChangedListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(
+            SingletonContainer::Get<WindowManager>().UnregisterSystemBarChangedListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessTouchOutsideRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessTouchOutsideRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     WLOGFI("called");
     if (window == nullptr) {
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<ITouchOutsideListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterTouchOutsideListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterTouchOutsideListener(thisListener));
     } else {
-        window->UnregisterTouchOutsideListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterTouchOutsideListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessScreenshotRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessScreenshotRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     WLOGFI("called");
     if (window == nullptr) {
         WLOGFE("%{public}sregister screenshot listener failed. window is null", isRegister? "" : "un");
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IScreenshotListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterScreenshotListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterScreenshotListener(thisListener));
     } else {
-        window->UnregisterScreenshotListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterScreenshotListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessDialogTargetTouchRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessDialogTargetTouchRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IDialogTargetTouchListener> thisListener(listener);
+    WmErrorCode ret = WmErrorCode::WM_OK;
     if (isRegister) {
-        window->RegisterDialogTargetTouchListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->RegisterDialogTargetTouchListener(thisListener));
     } else {
-        window->UnregisterDialogTargetTouchListener(thisListener);
+        ret = WM_JS_TO_ERROR_CODE_MAP.at(window->UnregisterDialogTargetTouchListener(thisListener));
     }
-    return true;
+    return ret;
 }
 
-bool JsWindowRegisterManager::ProcessDialogDeathRecipientRegister(sptr<JsWindowListener> listener,
+WmErrorCode JsWindowRegisterManager::ProcessDialogDeathRecipientRegister(sptr<JsWindowListener> listener,
     sptr<Window> window, bool isRegister)
 {
     if (window == nullptr) {
-        return false;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     sptr<IDialogDeathRecipientListener> thisListener(listener);
     if (isRegister) {
@@ -207,7 +218,7 @@ bool JsWindowRegisterManager::ProcessDialogDeathRecipientRegister(sptr<JsWindowL
     } else {
         window->UnregisterDialogDeathRecipientListener(thisListener);
     }
-    return true;
+    return WmErrorCode::WM_OK;
 }
 
 bool JsWindowRegisterManager::IsCallbackRegistered(std::string type, NativeValue* jsListenerObject)
@@ -226,50 +237,53 @@ bool JsWindowRegisterManager::IsCallbackRegistered(std::string type, NativeValue
     return false;
 }
 
-void JsWindowRegisterManager::RegisterListener(sptr<Window> window, std::string type,
+WmErrorCode JsWindowRegisterManager::RegisterListener(sptr<Window> window, std::string type,
     CaseType caseType, NativeEngine& engine, NativeValue* value)
 {
     std::lock_guard<std::mutex> lock(mtx_);
     if (IsCallbackRegistered(type, value)) {
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     if (listenerProcess_[caseType].count(type) == 0) {
         WLOGFE("[NAPI]Type %{public}s is not supported", type.c_str());
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     std::shared_ptr<NativeReference> callbackRef;
     callbackRef.reset(engine.CreateReference(value, 1));
     sptr<JsWindowListener> windowManagerListener = new(std::nothrow) JsWindowListener(&engine, callbackRef);
     if (windowManagerListener == nullptr) {
         WLOGFE("[NAPI]New JsWindowListener failed");
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
-    if (!((this->*listenerProcess_[caseType][type])(windowManagerListener, window, true))) {
+    WmErrorCode ret = (this->*listenerProcess_[caseType][type])(windowManagerListener, window, true);
+    if (ret != WmErrorCode::WM_OK) {
         WLOGFE("[NAPI]Register type %{public}s failed", type.c_str());
-        return;
+        return ret;
     }
     jsCbMap_[type][callbackRef] = windowManagerListener;
     WLOGFI("[NAPI]Register type %{public}s success! callback map size: %{public}zu",
         type.c_str(), jsCbMap_[type].size());
+    return WmErrorCode::WM_OK;
 }
 
-void JsWindowRegisterManager::UnregisterListener(sptr<Window> window, std::string type,
+WmErrorCode JsWindowRegisterManager::UnregisterListener(sptr<Window> window, std::string type,
     CaseType caseType, NativeValue* value)
 {
     std::lock_guard<std::mutex> lock(mtx_);
     if (jsCbMap_.empty() || jsCbMap_.find(type) == jsCbMap_.end()) {
         WLOGFE("[NAPI]Type %{public}s was not registerted", type.c_str());
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     if (listenerProcess_[caseType].count(type) == 0) {
         WLOGFE("[NAPI]Type %{public}s is not supported", type.c_str());
-        return;
+        return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
     }
     if (value == nullptr) {
         for (auto it = jsCbMap_[type].begin(); it != jsCbMap_[type].end();) {
-            if (!((this->*listenerProcess_[caseType][type])(it->second, window, false))) {
+            WmErrorCode ret = (this->*listenerProcess_[caseType][type])(it->second, window, false);
+            if (ret != WmErrorCode::WM_OK) {
                 WLOGFE("[NAPI]Unregister type %{public}s failed, no value", type.c_str());
-                return;
+                return ret;
             }
             jsCbMap_[type].erase(it++);
         }
@@ -280,16 +294,17 @@ void JsWindowRegisterManager::UnregisterListener(sptr<Window> window, std::strin
                 continue;
             }
             findFlag = true;
-            if (!(this->*listenerProcess_[caseType][type])(it->second, window, false)) {
+            WmErrorCode ret = (this->*listenerProcess_[caseType][type])(it->second, window, false);
+            if (ret != WmErrorCode::WM_OK) {
                 WLOGFE("[NAPI]Unregister type %{public}s failed", type.c_str());
-                return;
+                return ret;
             }
             jsCbMap_[type].erase(it);
             break;
         }
         if (!findFlag) {
             WLOGFE("[NAPI]Unregister type %{public}s failed because not found callback!", type.c_str());
-            return;
+            return WmErrorCode::WM_ERROR_STATE_ABNORMALLY;
         }
     }
     WLOGFI("[NAPI]Unregister type %{public}s success! callback map size: %{public}zu",
@@ -298,6 +313,7 @@ void JsWindowRegisterManager::UnregisterListener(sptr<Window> window, std::strin
     if (jsCbMap_[type].empty()) {
         jsCbMap_.erase(type);
     }
+    return WmErrorCode::WM_OK;
 }
 } // namespace Rosen
 } // namespace OHOS
diff --git a/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.h b/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.h
index 66fb641e..15b008cc 100644
--- a/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.h
+++ b/interfaces/kits/napi/window_runtime/window_napi/js_window_register_manager.h
@@ -33,23 +33,23 @@ class JsWindowRegisterManager {
 public:
     JsWindowRegisterManager();
     ~JsWindowRegisterManager();
-    void RegisterListener(sptr<Window> window, std::string type,
+    WmErrorCode RegisterListener(sptr<Window> window, std::string type,
         CaseType caseType, NativeEngine& engine, NativeValue* value);
-    void UnregisterListener(sptr<Window> window, std::string type,
+    WmErrorCode UnregisterListener(sptr<Window> window, std::string type,
         CaseType caseType, NativeValue* value);
 private:
     bool IsCallbackRegistered(std::string type, NativeValue* jsListenerObject);
-    bool ProcessWindowChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessSystemAvoidAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessAvoidAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessLifeCycleEventRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessOccupiedAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessSystemBarChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessTouchOutsideRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessScreenshotRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessDialogTargetTouchRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    bool ProcessDialogDeathRecipientRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
-    using Func_t = bool(JsWindowRegisterManager::*)(sptr<JsWindowListener>, sptr<Window> window, bool);
+    WmErrorCode ProcessWindowChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessSystemAvoidAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessAvoidAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessLifeCycleEventRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessOccupiedAreaChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessSystemBarChangeRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessTouchOutsideRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessScreenshotRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessDialogTargetTouchRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    WmErrorCode ProcessDialogDeathRecipientRegister(sptr<JsWindowListener> listener, sptr<Window> window, bool isRegister);
+    using Func_t = WmErrorCode(JsWindowRegisterManager::*)(sptr<JsWindowListener>, sptr<Window> window, bool);
     std::map<std::string, std::map<std::shared_ptr<NativeReference>, sptr<JsWindowListener>>> jsCbMap_;
     std::mutex mtx_;
     std::map<CaseType, std::map<std::string, Func_t>> listenerProcess_;
diff --git a/interfaces/kits/napi/window_runtime/window_napi/js_window_utils.cpp b/interfaces/kits/napi/window_runtime/window_napi/js_window_utils.cpp
index 953cdd7c..82d08b89 100644
--- a/interfaces/kits/napi/window_runtime/window_napi/js_window_utils.cpp
+++ b/interfaces/kits/napi/window_runtime/window_napi/js_window_utils.cpp
@@ -344,6 +344,8 @@ NativeValue* WindowErrorCodeInit(NativeEngine* engine)
     }
     object->SetProperty("WM_ERROR_NO_PERMISSION", CreateJsValue(*engine,
         static_cast<int32_t>(WmErrorCode::WM_ERROR_NO_PERMISSION)));
+    object->SetProperty("WM_ERROR_NOT_SYSTEM_APP", CreateJsValue(*engine,
+        static_cast<int32_t>(WmErrorCode::WM_ERROR_NOT_SYSTEM_APP)));
     object->SetProperty("WM_ERROR_INVALID_PARAM", CreateJsValue(*engine,
         static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_PARAM)));
     object->SetProperty("WM_ERROR_DEVICE_NOT_SUPPORT", CreateJsValue(*engine,
diff --git a/interfaces/kits/napi/window_runtime/window_stage_napi/js_window_stage.cpp b/interfaces/kits/napi/window_runtime/window_stage_napi/js_window_stage.cpp
index f03fb21a..ca3fd00c 100644
--- a/interfaces/kits/napi/window_runtime/window_stage_napi/js_window_stage.cpp
+++ b/interfaces/kits/napi/window_runtime/window_stage_napi/js_window_stage.cpp
@@ -481,8 +481,8 @@ NativeValue* JsWindowStage::OnSetShowOnLockScreen(NativeEngine& engine, NativeCa
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set show on lock screen permission denied!");
-        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_CALLING)));
-        return CreateJsValue(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_INVALID_CALLING));
+        engine.Throw(CreateJsError(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_NOT_SYSTEM_APP)));
+        return CreateJsValue(engine, static_cast<int32_t>(WmErrorCode::WM_ERROR_NOT_SYSTEM_APP));
     }
     if (info.argc < 1) {
         WLOGFE("[NAPI]Argc is invalid: %{public}zu", info.argc);
diff --git a/wm/include/window_adapter.h b/wm/include/window_adapter.h
index 6792cc07..7dde4414 100644
--- a/wm/include/window_adapter.h
+++ b/wm/include/window_adapter.h
@@ -47,7 +47,7 @@ public:
         sptr<MoveDragProperty>& moveDragProperty);
     virtual void ProcessPointDown(uint32_t windowId, bool isPointDown = true);
     virtual void ProcessPointUp(uint32_t windowId);
-    virtual void MinimizeAllAppWindows(DisplayId displayId);
+    virtual WMError MinimizeAllAppWindows(DisplayId displayId);
     virtual WMError ToggleShownStateForAllAppWindows();
     virtual WMError SetWindowLayoutMode(WindowLayoutMode mode);
     virtual WMError UpdateProperty(sptr<WindowProperty>& windowProperty, PropertyChangeAction action);
@@ -55,9 +55,9 @@ public:
     virtual WMError GetModeChangeHotZones(DisplayId displayId, ModeChangeHotZones& hotZones);
     virtual WMError UpdateRsTree(uint32_t windowId, bool isAdd);
     virtual WMError BindDialogTarget(uint32_t& windowId, sptr<IRemoteObject> targetToken);
-    virtual bool RegisterWindowManagerAgent(WindowManagerAgentType type,
+    virtual WMError RegisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent);
-    virtual bool UnregisterWindowManagerAgent(WindowManagerAgentType type,
+    virtual WMError UnregisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent);
 
     virtual WMError SetWindowAnimationController(const sptr<RSIWindowAnimationController>& controller);
diff --git a/wm/include/window_impl.h b/wm/include/window_impl.h
index 812c5f28..5bf856b1 100644
--- a/wm/include/window_impl.h
+++ b/wm/include/window_impl.h
@@ -125,8 +125,8 @@ public:
     virtual bool IsLayoutFullScreen() const override;
     virtual WMError SetWindowType(WindowType type) override;
     virtual WMError SetWindowMode(WindowMode mode) override;
-    virtual void SetAlpha(float alpha) override;
-    virtual void SetTransform(const Transform& trans) override;
+    virtual WMError SetAlpha(float alpha) override;
+    virtual WMError SetTransform(const Transform& trans) override;
     virtual WMError AddWindowFlag(WindowFlag flag) override;
     virtual WMError RemoveWindowFlag(WindowFlag flag) override;
     virtual WMError SetWindowFlags(uint32_t flags) override;
@@ -160,19 +160,19 @@ public:
     virtual WMError SetBrightness(float brightness) override;
     virtual float GetBrightness() const override;
     virtual WMError SetCallingWindow(uint32_t windowId) override;
-    virtual void SetPrivacyMode(bool isPrivacyMode) override;
+    virtual WMError SetPrivacyMode(bool isPrivacyMode) override;
     virtual bool IsPrivacyMode() const override;
     virtual void SetSystemPrivacyMode(bool isSystemPrivacyMode) override;
-    virtual void DisableAppWindowDecor() override;
+    virtual WMError DisableAppWindowDecor() override;
     virtual WMError BindDialogTarget(sptr<IRemoteObject> targetToken) override;
-    virtual void SetSnapshotSkip(bool isSkip) override;
+    virtual WMError SetSnapshotSkip(bool isSkip) override;
 
     // window effect
     virtual WMError SetCornerRadius(float cornerRadius) override;
     virtual WMError SetShadowRadius(float radius) override;
     virtual WMError SetShadowColor(std::string color) override;
-    virtual void SetShadowOffsetX(float offsetX) override;
-    virtual void SetShadowOffsetY(float offsetY) override;
+    virtual WMError SetShadowOffsetX(float offsetX) override;
+    virtual WMError SetShadowOffsetY(float offsetY) override;
     virtual WMError SetBlur(float radius) override;
     virtual WMError SetBackdropBlur(float radius) override;
     virtual WMError SetBackdropBlurStyle(WindowBlurStyle blurStyle) override;
@@ -187,26 +187,26 @@ public:
     virtual WMError RequestFocus() const override;
     virtual void SetInputEventConsumer(const std::shared_ptr<IInputEventConsumer>& inputEventConsumer) override;
 
-    virtual bool RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) override;
-    virtual bool RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) override;
-    virtual bool UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) override;
-    virtual bool UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) override;
-    virtual bool RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) override;
-    virtual bool UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) override;
-    virtual bool RegisterDragListener(const sptr<IWindowDragListener>& listener) override;
-    virtual bool UnregisterDragListener(const sptr<IWindowDragListener>& listener) override;
-    virtual bool RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) override;
-    virtual bool UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) override;
+    virtual WMError RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) override;
+    virtual WMError RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) override;
+    virtual WMError UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener) override;
+    virtual WMError UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener) override;
+    virtual WMError RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) override;
+    virtual WMError UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener) override;
+    virtual WMError RegisterDragListener(const sptr<IWindowDragListener>& listener) override;
+    virtual WMError UnregisterDragListener(const sptr<IWindowDragListener>& listener) override;
+    virtual WMError RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) override;
+    virtual WMError UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener) override;
     virtual void RegisterWindowDestroyedListener(const NotifyNativeWinDestroyFunc& func) override;
-    virtual bool RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) override;
-    virtual bool UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) override;
-    virtual bool RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) override;
-    virtual bool UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) override;
-    virtual bool RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener) override;
-    virtual bool RegisterScreenshotListener(const sptr<IScreenshotListener>& listener) override;
-    virtual bool UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener) override;
-    virtual bool RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) override;
-    virtual bool UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) override;
+    virtual WMError RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) override;
+    virtual WMError UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener) override;
+    virtual WMError RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) override;
+    virtual WMError UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener) override;
+    virtual WMError RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener) override;
+    virtual WMError RegisterScreenshotListener(const sptr<IScreenshotListener>& listener) override;
+    virtual WMError UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener) override;
+    virtual WMError RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) override;
+    virtual WMError UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener) override;
     virtual void RegisterDialogDeathRecipientListener(const sptr<IDialogDeathRecipientListener>& listener) override;
     virtual void UnregisterDialogDeathRecipientListener(const sptr<IDialogDeathRecipientListener>& listener) override;
     virtual void SetAceAbilityHandler(const sptr<IAceAbilityHandler>& handler) override;
@@ -262,8 +262,8 @@ public:
 private:
     template<typename T1, typename T2, typename Ret>
     using EnableIfSame = typename std::enable_if<std::is_same_v<T1, T2>, Ret>::type;
-    template<typename T> bool RegisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener);
-    template<typename T> bool UnregisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener);
+    template<typename T> WMError RegisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener);
+    template<typename T> WMError UnregisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener);
     template<typename T>
     inline EnableIfSame<T, IWindowLifeCycle, std::vector<wptr<IWindowLifeCycle>>> GetListeners()
     {
diff --git a/wm/src/window.cpp b/wm/src/window.cpp
index afc34edd..3e85dde5 100644
--- a/wm/src/window.cpp
+++ b/wm/src/window.cpp
@@ -25,7 +25,7 @@ namespace {
     constexpr HiviewDFX::HiLogLabel LABEL = {LOG_CORE, HILOG_DOMAIN_WINDOW, "Window"};
 }
 sptr<Window> Window::Create(const std::string& windowName, sptr<WindowOption>& option,
-    const std::shared_ptr<OHOS::AbilityRuntime::Context>& context)
+    const std::shared_ptr<OHOS::AbilityRuntime::Context>& context, WMError& errCode)
 {
     if (windowName.empty()) {
         WLOGFE("window name is empty");
@@ -51,6 +51,7 @@ sptr<Window> Window::Create(const std::string& windowName, sptr<WindowOption>& o
     }
     WMError error = windowImpl->Create(option->GetParentId(), context);
     if (error != WMError::WM_OK) {
+        errCode = error;
         return nullptr;
     }
     return windowImpl;
diff --git a/wm/src/window_adapter.cpp b/wm/src/window_adapter.cpp
index 9e1c1b75..5fb8614f 100644
--- a/wm/src/window_adapter.cpp
+++ b/wm/src/window_adapter.cpp
@@ -66,17 +66,17 @@ WMError WindowAdapter::RequestFocus(uint32_t windowId)
     return windowManagerServiceProxy_->RequestFocus(windowId);
 }
 
-bool WindowAdapter::RegisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowAdapter::RegisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(WMError::WM_ERROR_SAMGR);
     return windowManagerServiceProxy_->RegisterWindowManagerAgent(type, windowManagerAgent);
 }
 
-bool WindowAdapter::UnregisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowAdapter::UnregisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
-    INIT_PROXY_CHECK_RETURN(false);
+    INIT_PROXY_CHECK_RETURN(WMError::WM_ERROR_SAMGR);
     return windowManagerServiceProxy_->UnregisterWindowManagerAgent(type, windowManagerAgent);
 }
 
@@ -124,10 +124,10 @@ void WindowAdapter::ProcessPointUp(uint32_t windowId)
     return windowManagerServiceProxy_->ProcessPointUp(windowId);
 }
 
-void WindowAdapter::MinimizeAllAppWindows(DisplayId displayId)
+WMError WindowAdapter::MinimizeAllAppWindows(DisplayId displayId)
 {
-    INIT_PROXY_CHECK_RETURN();
-    windowManagerServiceProxy_->MinimizeAllAppWindows(displayId);
+    INIT_PROXY_CHECK_RETURN(WMError::WM_ERROR_SAMGR);
+    return windowManagerServiceProxy_->MinimizeAllAppWindows(displayId);
 }
 
 WMError WindowAdapter::ToggleShownStateForAllAppWindows()
diff --git a/wm/src/window_impl.cpp b/wm/src/window_impl.cpp
index e99f035d..9f1bfaf2 100755
--- a/wm/src/window_impl.cpp
+++ b/wm/src/window_impl.cpp
@@ -332,7 +332,7 @@ WMError WindowImpl::SetWindowType(WindowType type)
     WLOGFD("window id: %{public}u, type:%{public}u.", property_->GetWindowId(), static_cast<uint32_t>(type));
     if (type != WindowType::WINDOW_TYPE_SYSTEM_ALARM_WINDOW && !Permission::IsSystemCalling()) {
         WLOGFE("set window type permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if (!IsWindowValid()) {
         return WMError::WM_ERROR_INVALID_WINDOW;
@@ -386,26 +386,27 @@ WMError WindowImpl::SetWindowMode(WindowMode mode)
     return WMError::WM_OK;
 }
 
-void WindowImpl::SetAlpha(float alpha)
+WMError WindowImpl::SetAlpha(float alpha)
 {
     WLOGFI("[Client] Window %{public}u alpha %{public}f", property_->GetWindowId(), alpha);
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set alpha permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if (!IsWindowValid()) {
-        return;
+        return WMError::WM_ERROR_INVALID_WINDOW;
     }
     property_->SetAlpha(alpha);
     surfaceNode_->SetAlpha(alpha);
     RSTransaction::FlushImplicitTransaction();
+    return WMError::WM_OK;
 }
 
-void WindowImpl::SetTransform(const Transform& trans)
+WMError WindowImpl::SetTransform(const Transform& trans)
 {
     WLOGFI("[Client] Window %{public}u SetTransform", property_->GetWindowId());
     if (!IsWindowValid()) {
-        return;
+        return WMError::WM_ERROR_INVALID_WINDOW;
     }
     Transform oriTrans = property_->GetTransform();
     property_->SetTransform(trans);
@@ -414,12 +415,14 @@ void WindowImpl::SetTransform(const Transform& trans)
         WLOGFE("SetTransform errCode:%{public}d winId:%{public}u",
             static_cast<int32_t>(ret), property_->GetWindowId());
         property_->SetTransform(oriTrans); // reset to ori transform when update failed
+        return ret;
     }
     if (property_->IsDisplayZoomOn()) {
         TransformSurfaceNode(property_->GetZoomTransform());
     } else {
         TransformSurfaceNode(trans);
     }
+    return WMError::WM_OK;
 }
 
 const Transform& WindowImpl::GetTransform() const
@@ -1641,11 +1644,11 @@ std::string WindowImpl::TransferLifeCycleEventToString(LifeCycleEvent type) cons
     return event;
 }
 
-void WindowImpl::SetPrivacyMode(bool isPrivacyMode)
+WMError WindowImpl::SetPrivacyMode(bool isPrivacyMode)
 {
     property_->SetPrivacyMode(isPrivacyMode);
     surfaceNode_->SetSecurityLayer(isPrivacyMode || property_->GetSystemPrivacyMode());
-    UpdateProperty(PropertyChangeAction::ACTION_UPDATE_PRIVACY_MODE);
+    return UpdateProperty(PropertyChangeAction::ACTION_UPDATE_PRIVACY_MODE);
 }
 
 bool WindowImpl::IsPrivacyMode() const
@@ -1659,27 +1662,29 @@ void WindowImpl::SetSystemPrivacyMode(bool isSystemPrivacyMode)
     surfaceNode_->SetSecurityLayer(isSystemPrivacyMode || property_->GetPrivacyMode());
 }
 
-void WindowImpl::SetSnapshotSkip(bool isSkip)
+WMError WindowImpl::SetSnapshotSkip(bool isSkip)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set snapshot skip permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     surfaceNode_->SetSecurityLayer(isSkip || property_->GetSystemPrivacyMode());
+    return WMError::WM_OK;
 }
 
-void WindowImpl::DisableAppWindowDecor()
+WMError WindowImpl::DisableAppWindowDecor()
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("disable app window decor permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if (!WindowHelper::IsMainWindow(property_->GetWindowType())) {
         WLOGFE("window decoration is invalid on sub window");
-        return;
+        return WMError::WM_ERROR_INVALID_OPERATION;
     }
     WLOGFI("disable app window decoration.");
     isAppDecorEnable_ = false;
+    return WMError::WM_OK;
 }
 
 bool WindowImpl::IsDecorEnable() const
@@ -1799,60 +1804,60 @@ void WindowImpl::SetInputEventConsumer(const std::shared_ptr<IInputEventConsumer
     inputEventConsumer_ = inputEventConsumer;
 }
 
-bool WindowImpl::RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener)
+WMError WindowImpl::RegisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener)
 {
     return RegisterListenerLocked(lifecycleListeners_, listener);
 }
 
-bool WindowImpl::UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener)
+WMError WindowImpl::UnregisterLifeCycleListener(const sptr<IWindowLifeCycle>& listener)
 {
     return UnregisterListenerLocked(lifecycleListeners_, listener);
 }
 
-bool WindowImpl::RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener)
+WMError WindowImpl::RegisterWindowChangeListener(const sptr<IWindowChangeListener>& listener)
 {
     return RegisterListenerLocked(windowChangeListeners_, listener);
 }
 
-bool WindowImpl::UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener)
+WMError WindowImpl::UnregisterWindowChangeListener(const sptr<IWindowChangeListener>& listener)
 {
     return UnregisterListenerLocked(windowChangeListeners_, listener);
 }
 
-bool WindowImpl::RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener)
+WMError WindowImpl::RegisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener)
 {
-    bool ret = RegisterListenerLocked(avoidAreaChangeListeners_, listener);
+    WMError ret = RegisterListenerLocked(avoidAreaChangeListeners_, listener);
     if (avoidAreaChangeListeners_.size() == 1) {
         SingletonContainer::Get<WindowAdapter>().UpdateAvoidAreaListener(property_->GetWindowId(), true);
     }
     return ret;
 }
 
-bool WindowImpl::UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener)
+WMError WindowImpl::UnregisterAvoidAreaChangeListener(sptr<IAvoidAreaChangedListener>& listener)
 {
-    bool ret = UnregisterListenerLocked(avoidAreaChangeListeners_, listener);
+    WMError ret = UnregisterListenerLocked(avoidAreaChangeListeners_, listener);
     if (avoidAreaChangeListeners_.empty()) {
         SingletonContainer::Get<WindowAdapter>().UpdateAvoidAreaListener(property_->GetWindowId(), false);
     }
     return ret;
 }
 
-bool WindowImpl::RegisterDragListener(const sptr<IWindowDragListener>& listener)
+WMError WindowImpl::RegisterDragListener(const sptr<IWindowDragListener>& listener)
 {
     return RegisterListenerLocked(windowDragListeners_, listener);
 }
 
-bool WindowImpl::UnregisterDragListener(const sptr<IWindowDragListener>& listener)
+WMError WindowImpl::UnregisterDragListener(const sptr<IWindowDragListener>& listener)
 {
     return UnregisterListenerLocked(windowDragListeners_, listener);
 }
 
-bool WindowImpl::RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener)
+WMError WindowImpl::RegisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener)
 {
     return RegisterListenerLocked(displayMoveListeners_, listener);
 }
 
-bool WindowImpl::UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener)
+WMError WindowImpl::UnregisterDisplayMoveListener(sptr<IDisplayMoveListener>& listener)
 {
     return UnregisterListenerLocked(displayMoveListeners_, listener);
 }
@@ -1863,31 +1868,39 @@ void WindowImpl::RegisterWindowDestroyedListener(const NotifyNativeWinDestroyFun
     notifyNativefunc_ = std::move(func);
 }
 
-bool WindowImpl::RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener)
+WMError WindowImpl::RegisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener)
 {
     return RegisterListenerLocked(occupiedAreaChangeListeners_, listener);
 }
 
-bool WindowImpl::UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener)
+WMError WindowImpl::UnregisterOccupiedAreaChangeListener(const sptr<IOccupiedAreaChangeListener>& listener)
 {
     return UnregisterListenerLocked(occupiedAreaChangeListeners_, listener);
 }
 
-bool WindowImpl::RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener)
+WMError WindowImpl::RegisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener)
 {
+    if (!Permission::IsSystemCalling()) {
+        WLOGFE("register touch outside listener permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
     return RegisterListenerLocked(touchOutsideListeners_, listener);
 }
 
-bool WindowImpl::UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener)
+WMError WindowImpl::UnregisterTouchOutsideListener(const sptr<ITouchOutsideListener>& listener)
 {
     return UnregisterListenerLocked(touchOutsideListeners_, listener);
 }
 
-bool WindowImpl::RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener)
+WMError WindowImpl::RegisterAnimationTransitionController(const sptr<IAnimationTransitionController>& listener)
 {
+    if (!Permission::IsSystemCalling()) {
+        WLOGFE("register animation transition controller permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
     if (listener == nullptr) {
         WLOGFE("listener is nullptr");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     animationTransitionController_ = listener;
     wptr<WindowProperty> propertyToken(property_);
@@ -1906,25 +1919,25 @@ bool WindowImpl::RegisterAnimationTransitionController(const sptr<IAnimationTran
             }
         });
     }
-    return true;
+    return WMError::WM_OK;
 }
 
-bool WindowImpl::RegisterScreenshotListener(const sptr<IScreenshotListener>& listener)
+WMError WindowImpl::RegisterScreenshotListener(const sptr<IScreenshotListener>& listener)
 {
     return RegisterListenerLocked(screenshotListeners_, listener);
 }
 
-bool WindowImpl::UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener)
+WMError WindowImpl::UnregisterScreenshotListener(const sptr<IScreenshotListener>& listener)
 {
     return UnregisterListenerLocked(screenshotListeners_, listener);
 }
 
-bool WindowImpl::RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener)
+WMError WindowImpl::RegisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener)
 {
     return RegisterListenerLocked(dialogTargetTouchListeners_, listener);
 }
 
-bool WindowImpl::UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener)
+WMError WindowImpl::UnregisterDialogTargetTouchListener(const sptr<IDialogTargetTouchListener>& listener)
 {
     return UnregisterListenerLocked(dialogTargetTouchListeners_, listener);
 }
@@ -1946,34 +1959,34 @@ void WindowImpl::UnregisterDialogDeathRecipientListener(const sptr<IDialogDeathR
 }
 
 template<typename T>
-bool WindowImpl::RegisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener)
+WMError WindowImpl::RegisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener is nullptr");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     if (std::find(holder.begin(), holder.end(), listener) != holder.end()) {
         WLOGFE("Listener already registered");
-        return true;
+        return WMError::WM_OK;
     }
     holder.emplace_back(listener);
-    return true;
+    return WMError::WM_OK;
 }
 
 template<typename T>
-bool WindowImpl::UnregisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener)
+WMError WindowImpl::UnregisterListenerLocked(std::vector<sptr<T>>& holder, const sptr<T>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(mutex_);
     holder.erase(std::remove_if(holder.begin(), holder.end(),
         [listener](sptr<T> registeredListener) {
             return registeredListener == listener;
         }), holder.end());
-    return true;
+    return WMError::WM_OK;
 }
 
 void WindowImpl::SetAceAbilityHandler(const sptr<IAceAbilityHandler>& handler)
@@ -2992,7 +3005,7 @@ WMError WindowImpl::SetCornerRadius(float cornerRadius)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set corner radius permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set corner radius %{public}f", name_.c_str(), cornerRadius);
     if (MathHelper::LessNotEqual(cornerRadius, 0.0)) {
@@ -3007,7 +3020,7 @@ WMError WindowImpl::SetShadowRadius(float radius)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set shadow radius permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set shadow radius %{public}f", name_.c_str(), radius);
     if (MathHelper::LessNotEqual(radius, 0.0)) {
@@ -3022,7 +3035,7 @@ WMError WindowImpl::SetShadowColor(std::string color)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set shadow color permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set shadow color %{public}s", name_.c_str(), color.c_str());
     uint32_t colorValue;
@@ -3034,33 +3047,35 @@ WMError WindowImpl::SetShadowColor(std::string color)
     return WMError::WM_OK;
 }
 
-void WindowImpl::SetShadowOffsetX(float offsetX)
+WMError WindowImpl::SetShadowOffsetX(float offsetX)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set shadow offset x permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set shadow offsetX %{public}f", name_.c_str(), offsetX);
     surfaceNode_->SetShadowOffsetX(offsetX);
     RSTransaction::FlushImplicitTransaction();
+    return WMError::WM_OK;
 }
 
-void WindowImpl::SetShadowOffsetY(float offsetY)
+WMError WindowImpl::SetShadowOffsetY(float offsetY)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set shadow offset y permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set shadow offsetY %{public}f", name_.c_str(), offsetY);
     surfaceNode_->SetShadowOffsetY(offsetY);
     RSTransaction::FlushImplicitTransaction();
+    return WMError::WM_OK;
 }
 
 WMError WindowImpl::SetBlur(float radius)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set blur permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set blur radius %{public}f", name_.c_str(), radius);
     if (MathHelper::LessNotEqual(radius, 0.0)) {
@@ -3075,7 +3090,7 @@ WMError WindowImpl::SetBackdropBlur(float radius)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set backdrop blur permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set backdrop blur radius %{public}f", name_.c_str(), radius);
     if (MathHelper::LessNotEqual(radius, 0.0)) {
@@ -3090,7 +3105,7 @@ WMError WindowImpl::SetBackdropBlurStyle(WindowBlurStyle blurStyle)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set backdrop blur style permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     WLOGFI("[Client] Window %{public}s set backdrop blur style %{public}u", name_.c_str(), blurStyle);
     if (blurStyle < WindowBlurStyle::WINDOW_BLUR_OFF || blurStyle > WindowBlurStyle::WINDOW_BLUR_THICK) {
diff --git a/wm/src/window_manager.cpp b/wm/src/window_manager.cpp
index c318ea32..f34a4df0 100644
--- a/wm/src/window_manager.cpp
+++ b/wm/src/window_manager.cpp
@@ -239,49 +239,49 @@ void WindowManager::Impl::UpdateCameraFloatWindowStatus(uint32_t accessTokenId,
 
 WindowManager::WindowManager() : pImpl_(std::make_unique<Impl>()) {}
 
-bool WindowManager::RegisterFocusChangedListener(const sptr<IFocusChangedListener>& listener)
+WMError WindowManager::RegisterFocusChangedListener(const sptr<IFocusChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->focusChangedListenerAgent_ == nullptr) {
         pImpl_->focusChangedListenerAgent_ = new WindowManagerAgent();
         ret = SingletonContainer::Get<WindowAdapter>().RegisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_FOCUS, pImpl_->focusChangedListenerAgent_);
     }
-    if (!ret) {
+    if (ret != WMError::WM_ERROR_NULLPTR) {
         WLOGFW("RegisterWindowManagerAgent failed !");
         pImpl_->focusChangedListenerAgent_ = nullptr;
     } else {
         auto iter = std::find(pImpl_->focusChangedListeners_.begin(), pImpl_->focusChangedListeners_.end(), listener);
         if (iter != pImpl_->focusChangedListeners_.end()) {
             WLOGFW("Listener is already registered.");
-            return true;
+            return WMError::WM_OK;
         }
         pImpl_->focusChangedListeners_.push_back(listener);
     }
     return ret;
 }
 
-bool WindowManager::UnregisterFocusChangedListener(const sptr<IFocusChangedListener>& listener)
+WMError WindowManager::UnregisterFocusChangedListener(const sptr<IFocusChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
     auto iter = std::find(pImpl_->focusChangedListeners_.begin(), pImpl_->focusChangedListeners_.end(), listener);
     if (iter == pImpl_->focusChangedListeners_.end()) {
         WLOGFE("could not find this listener");
-        return true;
+        return WMError::WM_OK;
     }
     pImpl_->focusChangedListeners_.erase(iter);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->focusChangedListeners_.empty() && pImpl_->focusChangedListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<WindowAdapter>().UnregisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_FOCUS, pImpl_->focusChangedListenerAgent_);
@@ -290,21 +290,21 @@ bool WindowManager::UnregisterFocusChangedListener(const sptr<IFocusChangedListe
     return ret;
 }
 
-bool WindowManager::RegisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener)
+WMError WindowManager::RegisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->systemBarChangedListenerAgent_ == nullptr) {
         pImpl_->systemBarChangedListenerAgent_ = new WindowManagerAgent();
         ret = SingletonContainer::Get<WindowAdapter>().RegisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_SYSTEM_BAR, pImpl_->systemBarChangedListenerAgent_);
     }
-    if (!ret) {
+    if (ret != WMError::WM_OK) {
         WLOGFW("RegisterWindowManagerAgent failed !");
         pImpl_->systemBarChangedListenerAgent_ = nullptr;
     } else {
@@ -312,18 +312,18 @@ bool WindowManager::RegisterSystemBarChangedListener(const sptr<ISystemBarChange
             listener);
         if (iter != pImpl_->systemBarChangedListeners_.end()) {
             WLOGFW("Listener is already registered.");
-            return true;
+            return WMError::WM_OK;
         }
         pImpl_->systemBarChangedListeners_.push_back(listener);
     }
     return ret;
 }
 
-bool WindowManager::UnregisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener)
+WMError WindowManager::UnregisterSystemBarChangedListener(const sptr<ISystemBarChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
@@ -331,10 +331,10 @@ bool WindowManager::UnregisterSystemBarChangedListener(const sptr<ISystemBarChan
         listener);
     if (iter == pImpl_->systemBarChangedListeners_.end()) {
         WLOGFE("could not find this listener");
-        return true;
+        return WMError::WM_OK;
     }
     pImpl_->systemBarChangedListeners_.erase(iter);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->systemBarChangedListeners_.empty() && pImpl_->systemBarChangedListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<WindowAdapter>().UnregisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_SYSTEM_BAR, pImpl_->systemBarChangedListenerAgent_);
@@ -343,10 +343,10 @@ bool WindowManager::UnregisterSystemBarChangedListener(const sptr<ISystemBarChan
     return ret;
 }
 
-void WindowManager::MinimizeAllAppWindows(DisplayId displayId)
+WMError WindowManager::MinimizeAllAppWindows(DisplayId displayId)
 {
     WLOGFD("displayId %{public}" PRIu64"", displayId);
-    SingletonContainer::Get<WindowAdapter>().MinimizeAllAppWindows(displayId);
+    return SingletonContainer::Get<WindowAdapter>().MinimizeAllAppWindows(displayId);
 }
 
 WMError WindowManager::ToggleShownStateForAllAppWindows()
@@ -365,47 +365,47 @@ WMError WindowManager::SetWindowLayoutMode(WindowLayoutMode mode)
     return ret;
 }
 
-bool WindowManager::RegisterWindowUpdateListener(const sptr<IWindowUpdateListener> &listener)
+WMError WindowManager::RegisterWindowUpdateListener(const sptr<IWindowUpdateListener> &listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->windowUpdateListenerAgent_ == nullptr) {
         pImpl_->windowUpdateListenerAgent_ = new WindowManagerAgent();
         ret = SingletonContainer::Get<WindowAdapter>().RegisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_WINDOW_UPDATE, pImpl_->windowUpdateListenerAgent_);
     }
-    if (!ret) {
+    if (ret != WMError::WM_OK) {
         WLOGFW("RegisterWindowManagerAgent failed !");
         pImpl_->windowUpdateListenerAgent_ = nullptr;
     } else {
         auto iter = std::find(pImpl_->windowUpdateListeners_.begin(), pImpl_->windowUpdateListeners_.end(), listener);
         if (iter != pImpl_->windowUpdateListeners_.end()) {
             WLOGFI("Listener is already registered.");
-            return true;
+            return WMError::WM_OK;
         }
         pImpl_->windowUpdateListeners_.emplace_back(listener);
     }
     return ret;
 }
 
-bool WindowManager::UnregisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener)
+WMError WindowManager::UnregisterWindowUpdateListener(const sptr<IWindowUpdateListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
     auto iter = std::find(pImpl_->windowUpdateListeners_.begin(), pImpl_->windowUpdateListeners_.end(), listener);
     if (iter == pImpl_->windowUpdateListeners_.end()) {
         WLOGFE("could not find this listener");
-        return true;
+        return WMError::WM_OK;
     }
     pImpl_->windowUpdateListeners_.erase(iter);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->windowUpdateListeners_.empty() && pImpl_->windowUpdateListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<WindowAdapter>().UnregisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_WINDOW_UPDATE, pImpl_->windowUpdateListenerAgent_);
@@ -414,21 +414,21 @@ bool WindowManager::UnregisterWindowUpdateListener(const sptr<IWindowUpdateListe
     return ret;
 }
 
-bool WindowManager::RegisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener)
+WMError WindowManager::RegisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->windowVisibilityListenerAgent_ == nullptr) {
         pImpl_->windowVisibilityListenerAgent_ = new WindowManagerAgent();
         ret = SingletonContainer::Get<WindowAdapter>().RegisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_WINDOW_VISIBILITY,
             pImpl_->windowVisibilityListenerAgent_);
     }
-    if (!ret) {
+    if (ret != WMError::WM_OK) {
         WLOGFW("RegisterWindowManagerAgent failed !");
         pImpl_->windowVisibilityListenerAgent_ = nullptr;
     } else {
@@ -436,18 +436,18 @@ bool WindowManager::RegisterVisibilityChangedListener(const sptr<IVisibilityChan
             listener);
         if (iter != pImpl_->windowVisibilityListeners_.end()) {
             WLOGFW("Listener is already registered.");
-            return true;
+            return WMError::WM_OK;
         }
         pImpl_->windowVisibilityListeners_.emplace_back(listener);
     }
     return ret;
 }
 
-bool WindowManager::UnregisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener)
+WMError WindowManager::UnregisterVisibilityChangedListener(const sptr<IVisibilityChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
     pImpl_->windowVisibilityListeners_.erase(std::remove_if(pImpl_->windowVisibilityListeners_.begin(),
@@ -455,7 +455,7 @@ bool WindowManager::UnregisterVisibilityChangedListener(const sptr<IVisibilityCh
             return registeredListener == listener;
         }), pImpl_->windowVisibilityListeners_.end());
 
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->windowVisibilityListeners_.empty() && pImpl_->windowVisibilityListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<WindowAdapter>().UnregisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_WINDOW_VISIBILITY,
@@ -465,22 +465,22 @@ bool WindowManager::UnregisterVisibilityChangedListener(const sptr<IVisibilityCh
     return ret;
 }
 
-bool WindowManager::RegisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener)
+WMError WindowManager::RegisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->cameraFloatWindowChangedListenerAgent_ == nullptr) {
         pImpl_->cameraFloatWindowChangedListenerAgent_ = new WindowManagerAgent();
         ret = SingletonContainer::Get<WindowAdapter>().RegisterWindowManagerAgent(
             WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_CAMERA_FLOAT,
             pImpl_->cameraFloatWindowChangedListenerAgent_);
     }
-    if (!ret) {
+    if (ret != WMError::WM_OK) {
         WLOGFW("RegisterWindowManagerAgent failed !");
         pImpl_->cameraFloatWindowChangedListenerAgent_ = nullptr;
     } else {
@@ -488,18 +488,18 @@ bool WindowManager::RegisterCameraFloatWindowChangedListener(const sptr<ICameraF
             pImpl_->cameraFloatWindowChangedListeners_.end(), listener);
         if (iter != pImpl_->cameraFloatWindowChangedListeners_.end()) {
             WLOGFW("Listener is already registered.");
-            return true;
+            return WMError::WM_OK;
         }
         pImpl_->cameraFloatWindowChangedListeners_.push_back(listener);
     }
     return ret;
 }
 
-bool WindowManager::UnregisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener)
+WMError WindowManager::UnregisterCameraFloatWindowChangedListener(const sptr<ICameraFloatWindowChangedListener>& listener)
 {
     if (listener == nullptr) {
         WLOGFE("listener could not be null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
 
     std::lock_guard<std::recursive_mutex> lock(pImpl_->mutex_);
@@ -507,10 +507,10 @@ bool WindowManager::UnregisterCameraFloatWindowChangedListener(const sptr<ICamer
         pImpl_->cameraFloatWindowChangedListeners_.end(), listener);
     if (iter == pImpl_->cameraFloatWindowChangedListeners_.end()) {
         WLOGFE("could not find this listener");
-        return true;
+        return WMError::WM_OK;
     }
     pImpl_->cameraFloatWindowChangedListeners_.erase(iter);
-    bool ret = true;
+    WMError ret = WMError::WM_OK;
     if (pImpl_->cameraFloatWindowChangedListeners_.empty() &&
         pImpl_->cameraFloatWindowChangedListenerAgent_ != nullptr) {
         ret = SingletonContainer::Get<WindowAdapter>().UnregisterWindowManagerAgent(
diff --git a/wmserver/include/window_manager_service.h b/wmserver/include/window_manager_service.h
index 8d05f85e..83b89738 100644
--- a/wmserver/include/window_manager_service.h
+++ b/wmserver/include/window_manager_service.h
@@ -98,7 +98,7 @@ public:
     void ProcessPointDown(uint32_t windowId, bool isPointDown) override;
     void ProcessPointUp(uint32_t windowId) override;
     WMError GetTopWindowId(uint32_t mainWinId, uint32_t& topWinId) override;
-    void MinimizeAllAppWindows(DisplayId displayId) override;
+    WMError MinimizeAllAppWindows(DisplayId displayId) override;
     WMError ToggleShownStateForAllAppWindows() override;
     WMError SetWindowLayoutMode(WindowLayoutMode mode) override;
     WMError UpdateProperty(sptr<WindowProperty>& windowProperty, PropertyChangeAction action,
@@ -106,9 +106,9 @@ public:
     WMError GetAccessibilityWindowInfo(std::vector<sptr<AccessibilityWindowInfo>>& infos) override;
     WMError GetVisibilityWindowInfo(std::vector<sptr<WindowVisibilityInfo>>& infos) override;
 
-    bool RegisterWindowManagerAgent(WindowManagerAgentType type,
+    WMError RegisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) override;
-    bool UnregisterWindowManagerAgent(WindowManagerAgentType type,
+    WMError UnregisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) override;
 
     WMError SetWindowAnimationController(const sptr<RSIWindowAnimationController>& controller) override;
diff --git a/wmserver/include/zidl/window_manager_interface.h b/wmserver/include/zidl/window_manager_interface.h
index 46fcbf92..f769cec2 100644
--- a/wmserver/include/zidl/window_manager_interface.h
+++ b/wmserver/include/zidl/window_manager_interface.h
@@ -81,14 +81,14 @@ public:
         sptr<MoveDragProperty>& moveDragProperty) = 0;
     virtual void ProcessPointDown(uint32_t windowId, bool isPointDown) = 0;
     virtual void ProcessPointUp(uint32_t windowId) = 0;
-    virtual void MinimizeAllAppWindows(DisplayId displayId) = 0;
+    virtual WMError MinimizeAllAppWindows(DisplayId displayId) = 0;
     virtual WMError ToggleShownStateForAllAppWindows() = 0;
     virtual WMError SetWindowLayoutMode(WindowLayoutMode mode) = 0;
     virtual WMError UpdateProperty(sptr<WindowProperty>& windowProperty, PropertyChangeAction action,
         bool isAsyncTask = false) = 0;
-    virtual bool RegisterWindowManagerAgent(WindowManagerAgentType type,
+    virtual WMError RegisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) = 0;
-    virtual bool UnregisterWindowManagerAgent(WindowManagerAgentType type,
+    virtual WMError UnregisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) = 0;
     virtual WMError GetAccessibilityWindowInfo(std::vector<sptr<AccessibilityWindowInfo>>& infos) = 0;
     virtual WMError GetVisibilityWindowInfo(std::vector<sptr<WindowVisibilityInfo>>& infos) = 0;
diff --git a/wmserver/include/zidl/window_manager_proxy.h b/wmserver/include/zidl/window_manager_proxy.h
index ae5b75aa..2bdd7a5c 100644
--- a/wmserver/include/zidl/window_manager_proxy.h
+++ b/wmserver/include/zidl/window_manager_proxy.h
@@ -42,14 +42,14 @@ public:
         sptr<MoveDragProperty>& moveDragProperty) override;
     void ProcessPointDown(uint32_t windowId, bool isPointDown) override;
     void ProcessPointUp(uint32_t windowId) override;
-    void MinimizeAllAppWindows(DisplayId displayId) override;
+    WMError MinimizeAllAppWindows(DisplayId displayId) override;
     WMError ToggleShownStateForAllAppWindows() override;
     WMError SetWindowLayoutMode(WindowLayoutMode mode) override;
     WMError UpdateProperty(sptr<WindowProperty>& windowProperty, PropertyChangeAction action,
         bool isAsyncTask = false) override;
-    bool RegisterWindowManagerAgent(WindowManagerAgentType type,
+    WMError RegisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) override;
-    bool UnregisterWindowManagerAgent(WindowManagerAgentType type,
+    WMError UnregisterWindowManagerAgent(WindowManagerAgentType type,
         const sptr<IWindowManagerAgent>& windowManagerAgent) override;
     WMError SetWindowAnimationController(const sptr<RSIWindowAnimationController>& controller) override;
 
diff --git a/wmserver/src/window_manager_service.cpp b/wmserver/src/window_manager_service.cpp
index f5d27b57..31315fb5 100644
--- a/wmserver/src/window_manager_service.cpp
+++ b/wmserver/src/window_manager_service.cpp
@@ -52,6 +52,8 @@ namespace OHOS {
 namespace Rosen {
 namespace {
     constexpr HiviewDFX::HiLogLabel LABEL = {LOG_CORE, HILOG_DOMAIN_WINDOW, "WindowManagerService"};
+    const std::string SYSTEM_FLOAT_WINDOW_PERMISSION = "ohos.permission.SYSTEM_FLOAT_WINDOW";
+    const std::string PRIVACY_WINDOW_PERMISSION = "ohos.permission.PRIVACY_WINDOW";
 }
 WM_IMPLEMENT_SINGLE_INSTANCE(WindowManagerService)
 
@@ -652,6 +654,12 @@ WMError WindowManagerService::CreateWindow(sptr<IWindow>& window, sptr<WindowPro
         WindowHelper::IsSystemWindow(property->GetWindowType());
     if (isNeedSystemPrivilege && !Permission::IsSystemCalling()) {
         WLOGFE("create system window permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
+    bool isNeedCheckPermission = property->GetWindowType() == WindowType::WINDOW_TYPE_FLOAT ||
+        property->GetWindowType() == WindowType::WINDOW_TYPE_FLOAT_CAMERA;
+    if(isNeedCheckPermission && !Permission::CheckCallingPermission(SYSTEM_FLOAT_WINDOW_PERMISSION)) {
+        WLOGFE("create float window no permission!");
         return WMError::WM_ERROR_INVALID_PERMISSION;
     }
     int pid = IPCSkeleton::GetCallingPid();
@@ -674,10 +682,17 @@ WMError WindowManagerService::AddWindow(sptr<WindowProperty>& property)
         property->GetWindowType() != WindowType::WINDOW_TYPE_SYSTEM_ALARM_WINDOW &&
         property->GetWindowType() != WindowType::WINDOW_TYPE_TOAST &&
         WindowHelper::IsSystemWindow(property->GetWindowType());
-    if ((isNeedSystemPrivilege ||
-        property->GetAnimationFlag() == static_cast<uint32_t>(WindowAnimation::CUSTOM)) &&
+    bool showWithAnimation = (property->GetAnimationFlag() == static_cast<uint32_t>(WindowAnimation::CUSTOM) ||
+        property->GetAnimationFlag() == static_cast<uint32_t>(WindowAnimation::DEFAULT)) && !WindowHelper::IsAppWindow(property->GetWindowType());
+    if ((isNeedSystemPrivilege || showWithAnimation) &&
         !Permission::IsSystemCalling()) {
         WLOGFE("add window with animation permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
+    bool isNeedCheckPermission = property->GetWindowType() == WindowType::WINDOW_TYPE_FLOAT ||
+        property->GetWindowType() == WindowType::WINDOW_TYPE_FLOAT_CAMERA;
+    if(isNeedCheckPermission && !Permission::CheckCallingPermission(SYSTEM_FLOAT_WINDOW_PERMISSION)) {
+        WLOGFE("show float window no permission!");
         return WMError::WM_ERROR_INVALID_PERMISSION;
     }
     return PostSyncTask([this, &property]() {
@@ -701,6 +716,10 @@ WMError WindowManagerService::AddWindow(sptr<WindowProperty>& property)
 
 WMError WindowManagerService::RemoveWindow(uint32_t windowId)
 {
+    if (!Permission::IsSystemCalling()) {
+        WLOGFE("remove window permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
     return PostSyncTask([this, windowId]() {
         WLOGFI("[WMS] Remove: %{public}u", windowId);
         HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "wms:RemoveWindow(%u)", windowId);
@@ -768,19 +787,19 @@ AvoidArea WindowManagerService::GetAvoidAreaByType(uint32_t windowId, AvoidAreaT
     });
 }
 
-bool WindowManagerService::RegisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowManagerService::RegisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("register windowManager agent permission denied!");
-        return false;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if ((windowManagerAgent == nullptr) || (windowManagerAgent->AsObject() == nullptr)) {
         WLOGFE("windowManagerAgent is null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     return PostSyncTask([this, &windowManagerAgent, type]() {
-        bool ret = WindowManagerAgentController::GetInstance().RegisterWindowManagerAgent(windowManagerAgent, type);
+        WMError ret = WindowManagerAgentController::GetInstance().RegisterWindowManagerAgent(windowManagerAgent, type) ? WMError::WM_OK : WMError::WM_ERROR_NULLPTR;
         if (type == WindowManagerAgentType::WINDOW_MANAGER_AGENT_TYPE_SYSTEM_BAR) { // if system bar, notify once
             windowController_->NotifySystemBarTints();
         }
@@ -788,19 +807,19 @@ bool WindowManagerService::RegisterWindowManagerAgent(WindowManagerAgentType typ
     });
 }
 
-bool WindowManagerService::UnregisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowManagerService::UnregisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("unregister windowManager agent permission denied!");
-        return false;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if ((windowManagerAgent == nullptr) || (windowManagerAgent->AsObject() == nullptr)) {
         WLOGFE("windowManagerAgent is null");
-        return false;
+        return WMError::WM_ERROR_NULLPTR;
     }
     return PostSyncTask([this, &windowManagerAgent, type]() {
-        return WindowManagerAgentController::GetInstance().UnregisterWindowManagerAgent(windowManagerAgent, type);
+        return WindowManagerAgentController::GetInstance().UnregisterWindowManagerAgent(windowManagerAgent, type) ? WMError::WM_OK : WMError::WM_ERROR_NULLPTR;
     });
 }
 
@@ -808,7 +827,7 @@ WMError WindowManagerService::SetWindowAnimationController(const sptr<RSIWindowA
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set window animation controller permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     if (controller == nullptr) {
         WLOGFE("RSWindowAnimation: Failed to set window animation controller, controller is null!");
@@ -948,24 +967,25 @@ void WindowManagerService::NotifyWindowClientPointUp(uint32_t windowId,
     });
 }
 
-void WindowManagerService::MinimizeAllAppWindows(DisplayId displayId)
+WMError WindowManagerService::MinimizeAllAppWindows(DisplayId displayId)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("minimize all appWindows permission denied!");
-        return;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     PostAsyncTask([this, displayId]() {
         HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "wms:MinimizeAllAppWindows(%" PRIu64")", displayId);
         WLOGFI("displayId %{public}" PRIu64"", displayId);
         windowController_->MinimizeAllAppWindows(displayId);
     });
+    return WMError::WM_OK;
 }
 
 WMError WindowManagerService::ToggleShownStateForAllAppWindows()
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("toggle shown state for all appwindows permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     PostAsyncTask([this]() {
         HITRACE_METER_FMT(HITRACE_TAG_WINDOW_MANAGER, "wms:ToggleShownStateForAllAppWindows");
@@ -985,7 +1005,7 @@ WMError WindowManagerService::SetWindowLayoutMode(WindowLayoutMode mode)
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("set window layout mode permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     return PostSyncTask([this, mode]() {
         WLOGFI("layoutMode: %{public}u", mode);
@@ -1005,9 +1025,12 @@ WMError WindowManagerService::UpdateProperty(sptr<WindowProperty>& windowPropert
         action == PropertyChangeAction::ACTION_UPDATE_TRANSFORM_PROPERTY) &&
         !Permission::IsSystemCalling()) {
         WLOGFE("SetForbidSplitMove or SetShowWhenLocked or SetTranform or SetTurnScreenOn permission denied!");
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
+    }
+    if (action == PropertyChangeAction::ACTION_UPDATE_PRIVACY_MODE && !Permission::CheckCallingPermission(PRIVACY_WINDOW_PERMISSION)) {
+        WLOGFE("set window privacy mode no permission!");
         return WMError::WM_ERROR_INVALID_PERMISSION;
     }
-
     if (action == PropertyChangeAction::ACTION_UPDATE_TRANSFORM_PROPERTY) {
         return PostSyncTask([this, windowProperty, action]() mutable {
             windowController_->UpdateProperty(windowProperty, action);
@@ -1042,7 +1065,7 @@ WMError WindowManagerService::GetAccessibilityWindowInfo(std::vector<sptr<Access
 {
     if (!Permission::IsSystemServiceCalling()) {
         WLOGFE("get accessibility window info permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     return PostSyncTask([this, &infos]() {
         return windowController_->GetAccessibilityWindowInfo(infos);
@@ -1140,7 +1163,7 @@ WMError WindowManagerService::BindDialogTarget(uint32_t& windowId, sptr<IRemoteO
 {
     if (!Permission::IsSystemCalling()) {
         WLOGFE("bind dialog target permission denied!");
-        return WMError::WM_ERROR_INVALID_PERMISSION;
+        return WMError::WM_ERROR_NOT_SYSTEM_APP;
     }
     return PostSyncTask([this, &windowId, targetToken]() {
         return windowController_->BindDialogTarget(windowId, targetToken);
diff --git a/wmserver/src/zidl/window_manager_proxy.cpp b/wmserver/src/zidl/window_manager_proxy.cpp
index ce1d9abc..df47b166 100644
--- a/wmserver/src/zidl/window_manager_proxy.cpp
+++ b/wmserver/src/zidl/window_manager_proxy.cpp
@@ -196,7 +196,7 @@ AvoidArea WindowManagerProxy::GetAvoidAreaByType(uint32_t windowId, AvoidAreaTyp
     return *area;
 }
 
-bool WindowManagerProxy::RegisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowManagerProxy::RegisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
     MessageParcel data;
@@ -204,29 +204,29 @@ bool WindowManagerProxy::RegisterWindowManagerAgent(WindowManagerAgentType type,
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("WriteInterfaceToken failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteUint32(static_cast<uint32_t>(type))) {
         WLOGFE("Write type failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteRemoteObject(windowManagerAgent->AsObject())) {
         WLOGFE("Write IWindowManagerAgent failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (Remote()->SendRequest(static_cast<uint32_t>(WindowManagerMessage::TRANS_ID_REGISTER_WINDOW_MANAGER_AGENT),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SendRequest failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
-    return reply.ReadBool();
+    return static_cast<WMError>(reply.ReadInt32());
 }
 
-bool WindowManagerProxy::UnregisterWindowManagerAgent(WindowManagerAgentType type,
+WMError WindowManagerProxy::UnregisterWindowManagerAgent(WindowManagerAgentType type,
     const sptr<IWindowManagerAgent>& windowManagerAgent)
 {
     MessageParcel data;
@@ -234,26 +234,26 @@ bool WindowManagerProxy::UnregisterWindowManagerAgent(WindowManagerAgentType typ
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("WriteInterfaceToken failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteUint32(static_cast<uint32_t>(type))) {
         WLOGFE("Write type failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (!data.WriteRemoteObject(windowManagerAgent->AsObject())) {
         WLOGFE("Write IWindowManagerAgent failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
     if (Remote()->SendRequest(static_cast<uint32_t>(WindowManagerMessage::TRANS_ID_UNREGISTER_WINDOW_MANAGER_AGENT),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SendRequest failed");
-        return false;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
 
-    return reply.ReadBool();
+    return static_cast<WMError>(reply.ReadInt32());
 }
 
 WMError WindowManagerProxy::SetWindowAnimationController(const sptr<RSIWindowAnimationController>& controller)
@@ -358,23 +358,33 @@ void WindowManagerProxy::ProcessPointUp(uint32_t windowId)
     }
 }
 
-void WindowManagerProxy::MinimizeAllAppWindows(DisplayId displayId)
+WMError WindowManagerProxy::MinimizeAllAppWindows(DisplayId displayId)
 {
+    WLOGFI("called");
     MessageParcel data;
     MessageParcel reply;
     MessageOption option;
     if (!data.WriteInterfaceToken(GetDescriptor())) {
         WLOGFE("WriteInterfaceToken failed");
-        return;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
     if (!data.WriteUint64(displayId)) {
         WLOGFE("Write displayId failed");
-        return;
+        return WMError::WM_ERROR_IPC_FAILED;
     }
     if (Remote()->SendRequest(static_cast<uint32_t>(WindowManagerMessage::TRANS_ID_MINIMIZE_ALL_APP_WINDOWS),
         data, reply, option) != ERR_NONE) {
         WLOGFE("SendRequest failed");
+        return WMError::WM_ERROR_IPC_FAILED;
     }
+
+    int32_t ret;
+    if (!reply.ReadInt32(ret)) {
+        return WMError::WM_ERROR_IPC_FAILED;
+    }
+
+    WLOGFE("MinimizeAllAppWindows: %{public}u", ret);
+    return static_cast<WMError>(ret);
 }
 
 WMError WindowManagerProxy::ToggleShownStateForAllAppWindows()
diff --git a/wmserver/src/zidl/window_manager_stub.cpp b/wmserver/src/zidl/window_manager_stub.cpp
index 61e133c7..e105ff80 100644
--- a/wmserver/src/zidl/window_manager_stub.cpp
+++ b/wmserver/src/zidl/window_manager_stub.cpp
@@ -89,8 +89,8 @@ int32_t WindowManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data, M
             sptr<IRemoteObject> windowManagerAgentObject = data.ReadRemoteObject();
             sptr<IWindowManagerAgent> windowManagerAgentProxy =
                 iface_cast<IWindowManagerAgent>(windowManagerAgentObject);
-            bool ret = RegisterWindowManagerAgent(type, windowManagerAgentProxy);
-            reply.WriteBool(ret);
+            WMError errCode = RegisterWindowManagerAgent(type, windowManagerAgentProxy);
+            reply.WriteInt32(static_cast<int32_t>(errCode));
             break;
         }
         case WindowManagerMessage::TRANS_ID_UNREGISTER_WINDOW_MANAGER_AGENT: {
@@ -98,8 +98,8 @@ int32_t WindowManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data, M
             sptr<IRemoteObject> windowManagerAgentObject = data.ReadRemoteObject();
             sptr<IWindowManagerAgent> windowManagerAgentProxy =
                 iface_cast<IWindowManagerAgent>(windowManagerAgentObject);
-            bool ret = UnregisterWindowManagerAgent(type, windowManagerAgentProxy);
-            reply.WriteBool(ret);
+            WMError errCode = UnregisterWindowManagerAgent(type, windowManagerAgentProxy);
+            reply.WriteInt32(static_cast<int32_t>(errCode));
             break;
         }
         case WindowManagerMessage::TRANS_ID_NOTIFY_READY_MOVE_OR_DRAG: {
@@ -129,7 +129,8 @@ int32_t WindowManagerStub::OnRemoteRequest(uint32_t code, MessageParcel &data, M
             break;
         }
         case WindowManagerMessage::TRANS_ID_MINIMIZE_ALL_APP_WINDOWS: {
-            MinimizeAllAppWindows(data.ReadUint64());
+            WMError errCode = MinimizeAllAppWindows(data.ReadUint64());
+            reply.WriteInt32(static_cast<int32_t>(errCode));
             break;
         }
         case WindowManagerMessage::TRANS_ID_TOGGLE_SHOWN_STATE_FOR_ALL_APP_WINDOWS: {
