From a61cddfc9b4601dcbd0486e43fc3c33653c01c88 Mon Sep 17 00:00:00 2001
From: xingyanan <xingyanan2@huawei.com>
Date: Mon, 27 Jun 2022 21:30:52 +0800
Subject: [PATCH] split start window

Signed-off-by: xingyanan <xingyanan2@huawei.com>
Change-Id: I9cfbd934932be339cd4381bc541cc4cac658e77b
---
 interfaces/innerkits/wm/wm_common.h           |   1 +
 .../config/rk3568/window_manager_config.xml   |   2 +-
 resources/media/BUILD.gn                      |  12 +-
 resources/media/img/bg_place_holder.png       | Bin 0 -> 3500 bytes
 utils/BUILD.gn                                |   2 +
 utils/draw_surface.cpp                        | 195 ++++++++++++++++++
 utils/include/draw_surface.h                  |  48 +++++
 utils/include/surface_draw.h                  |  18 ++
 utils/src/surface_draw.cpp                    | 170 +++++++++++++++
 wm/src/window_impl.cpp                        |   4 +
 wmserver/BUILD.gn                             |   1 +
 wmserver/include/window_inner_manager.h       |  33 +++
 wmserver/include/window_pair.h                |   1 +
 wmserver/include/window_zorder_policy.h       |   1 +
 wmserver/src/window_inner_manager.cpp         | 183 +++++++++++++++-
 wmserver/src/window_pair.cpp                  |  20 +-
 16 files changed, 685 insertions(+), 6 deletions(-)
 create mode 100644 resources/media/img/bg_place_holder.png
 create mode 100644 utils/draw_surface.cpp
 create mode 100644 utils/include/draw_surface.h

diff --git a/interfaces/innerkits/wm/wm_common.h b/interfaces/innerkits/wm/wm_common.h
index 24da28ce..bf4a8ccf 100644
--- a/interfaces/innerkits/wm/wm_common.h
+++ b/interfaces/innerkits/wm/wm_common.h
@@ -43,6 +43,7 @@ enum class WindowType : uint32_t {
     ABOVE_APP_SYSTEM_WINDOW_BASE = 2100,
     WINDOW_TYPE_APP_LAUNCHING = ABOVE_APP_SYSTEM_WINDOW_BASE,
     WINDOW_TYPE_DOCK_SLICE,
+    WINDOW_TYPE_PLACE_HOLDER,
     WINDOW_TYPE_INCOMING_CALL,
     WINDOW_TYPE_SEARCHING_BAR,
     WINDOW_TYPE_SYSTEM_ALARM_WINDOW,
diff --git a/resources/config/rk3568/window_manager_config.xml b/resources/config/rk3568/window_manager_config.xml
index 70ca77e2..9c11c5a9 100644
--- a/resources/config/rk3568/window_manager_config.xml
+++ b/resources/config/rk3568/window_manager_config.xml
@@ -15,7 +15,7 @@
  -->
  <Configs>
     <!--decor enable is true means app main window show decoration-->
-    <decor enable="false"></decor>
+    <decor enable="true"></decor>
     <!--max number of main window that could be shown on display-->
     <maxAppWindowNumber>100</maxAppWindowNumber>
     <!--minimizeByOther enable is true means fullscreen window will be minmized by other fullscreen window-->
diff --git a/resources/media/BUILD.gn b/resources/media/BUILD.gn
index 1f2b8c85..6d152d78 100644
--- a/resources/media/BUILD.gn
+++ b/resources/media/BUILD.gn
@@ -19,6 +19,16 @@ ohos_prebuilt_etc("window_divider_image") {
   relative_install_dir = "window/resources"
 }
 
+ohos_prebuilt_etc("window_place_holder_image") {
+  source = "//foundation/windowmanager/resources/media/img/bg_place_holder.png"
+  part_name = "window_manager"
+  subsystem_name = "window"
+  relative_install_dir = "window/resources"
+}
+
+
 group("window_resources_media") {
-  deps = [ ":window_divider_image" ]
+  deps = [ ":window_divider_image",
+           ":window_place_holder_image"
+         ]
 }
diff --git a/resources/media/img/bg_place_holder.png b/resources/media/img/bg_place_holder.png
new file mode 100644
index 0000000000000000000000000000000000000000..9936aee1a38039dba2ddfacaf56ce9d8c94a1f59
GIT binary patch
literal 3500
zcmeH~k55xa9Ker?ii(mfnUINK+>EJHV2sg*m0zM$>I71M01padt|~SyqSykZ1%JUd
z9cXA+#-L1H!Htyq>$O0kW$U2P1}ma1Qr;{0<~sH))v~tK(ss{3V+qOKeJ|hp=DwHv
z-re_e-{fTNS-bkZ)c}CCnR|CJ03Z=v5(rsAh<_`eydlJ@lY8?|0}%86+Zt3UP2~~B
zMVY(O4_3C>ko`>?b9d@yPXGE)cpH&WcWj|g+#+4OvR_d{Qh#`<X62)h3xCwFCGFn)
z&egG7X>|yq<PJuzpS?`u=swHnL|lQYpV5QJw)Uc@cFBP=-6F3|8MxJh&!d9Afq_T~
zttvi7AMZjNP{9r`bp9aQCKaPlK>-`*TZGCvo{AquG0d|HOioJ+%QLFrXv0z$A9a={
zNeot>f|FqvE@;D|!9udLJW^?#tf59`d3~ay7M9SIuD??Vmqa{>3uWcE@KQRWk*TS|
z&&MmK6r6-*0EFer;3tsMC#u~h4aKNMP1r<3$pp%qiVKy>aL9OOV^`^9F_XzGEG|xM
zw|Z`I%z5m00eF?>M7?pLW}3mvG1r$wD9R&E{N-t6>AhI>!u6Vf&uyznN>=yv^-<fi
zva9VXRPf1LcaR)*oni8&;-p6Gj>X<(oIE9{9WtB<4-eORYEWWvG)d>|{r;W?#)C)R
zCY=-2(+onUNht{dy?j{AI3YX2=4g6wHJtd;?R^Xh@UxuO&Y7B&=!e$%8?1bnRQzUq
zxYn$QH_W@99qX_)>9DdJ08~=Bxi6bk$lOU<R2bebqBLTMWX?Q#6*jDr;Yn=<tCnVH
zK)rcf_H{9%h4oDBe}i{*h~CT+o))JvL7f}t&5H6&&PyD#|EAk-!uusBWMyrukL&MT
zCJNrKa6C{3#%J#d=SL};YS+tWGZjg)@r1$o+axeO2<;=EiKy2jT=(~8h3^oVm5aVw
zuI88%WAqGx9qY#Z9kqVXoWtQ*aJ<mJaD8;%>k9{UmOb{tj?U8R3R+a)c}0?sDRZ85
zXJ{21=iJAEuJKauKizVX^ZD?l;fv8Ag$5gOR=&R`qMlKdj|T4Nh}v9o`P@KnZv+>y
z><y|bW)MMSv26xAS?-G&%GS7xi`)GHhd#E+WHK2SgQk}yhH4Axo@UfL3k&&_?fS<Z
z$pY6LWfc)UCZe!4JFwBS8Vm*#3R!fM?sZZ9a<G`rF&}Oyp`wU?1Vre@+H1k9t2beF
z;@!ZAYH=Vq1f;A}x)%mtlL6Rt8GyPp;sTP08ACoG6jzoMOZ%~O9F}gw(qpjn7B1z6
z|8Z)}AWJp&bO7A!o3P8QaVM__(~?lw$Y3Mi{s6$&WA!ByBjr;>TWtd1%1_^6y$YiO
z!Xf(XW&lz|8Eg(>;~ikz3hCvs00c)6#_Jli_bm2oj2Z(UzDt1T)n4D1fys-)<1!9G
zb2YRmIbVg0QXBPmwiAG#LV}Ht1*sMUm8909#K<YafFMJW#G0~y{4un_qDvzvC`$&*
z@ua5^U(PL~P$;ZOowJgbh4-tsOU2#Y-2u;^&Dk-R_ACpUKL1o;*Tya8lBEbjxs2rz
zYv-vD&udJVOE7CJm&;X`$&&j6*GNDkM!jmWBNjGl5us+sIpZY6Zl{wAWKIoRMj3QJ
z{{?`BO-_OUD<#(27%6QV|EROp%1Tr23$k`)ceqMhMahlWUDZkgwTkV&OtvjrV21~0
zApd0R5VaAH3nfT68e#_$4D%gaGmlBnw;ve-LjipbJ2`4yL-=@tPbhPido;mA+0wX1
z3@dH*AJtf52i>W2gQ~3nMD;>AgDq5V*UJTVFNAM6<|tlM_vzLuVn$0NwjhU%TZc~p
zK>G?7$H(d&cC*3>;eKn%f)Vs4k6{E`-pC_?y0G5}k58ZmrSNZNP!63eHC8XOMuGt?
zxJ<STOk+>}s#52*ycqUIg@BW(#Qrz)s;WFc668ED3|j$uqw)Tpz?zB+d0T$>pN5F<
P7s%Y5wX0|67w7&1Q$p_}

literal 0
HcmV?d00001

diff --git a/utils/BUILD.gn b/utils/BUILD.gn
index a04be886..6723a668 100644
--- a/utils/BUILD.gn
+++ b/utils/BUILD.gn
@@ -45,6 +45,7 @@ ohos_shared_library("libwmutil") {
     "src/window_property.cpp",
     "src/window_transition_info.cpp",
     "src/wm_trace.cpp",
+    "draw_surface.cpp"
   ]
 
   configs = [ ":libwmutil_private_config" ]
@@ -54,6 +55,7 @@ ohos_shared_library("libwmutil") {
   deps = [
     "//foundation/graphic/graphic_2d/rosen/modules/render_service_base:librender_service_base",
     "//foundation/graphic/graphic_2d/rosen/modules/render_service_client:librender_service_client",
+    "//foundation/graphic/graphic_2d/rosen/modules/2d_graphics:2d_graphics",
     "//third_party/flutter/build/skia:ace_skia_ohos",
   ]
 
diff --git a/utils/draw_surface.cpp b/utils/draw_surface.cpp
new file mode 100644
index 00000000..06a0aa5a
--- /dev/null
+++ b/utils/draw_surface.cpp
@@ -0,0 +1,195 @@
+/*
+ * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "draw_surface.h"
+#include "image/bitmap.h"
+#include "image_source.h"
+#include "image_type.h"
+#include "image_utils.h"
+#include "pixel_map.h"
+#include "window_manager_hilog.h"
+
+namespace OHOS {
+namespace Rosen {
+namespace {
+    constexpr HiviewDFX::HiLogLabel LABEL = {LOG_CORE, HILOG_DOMAIN_WINDOW, "DrawSurface"};
+} // namespace
+
+bool DrawSurface::DrawImage(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+    const std::string& imagePath)
+{
+    sptr<OHOS::Surface> layer = GetLayer(surfaceNode);
+    if (layer == nullptr) {
+        WLOGFE("layer is nullptr");
+        return false;
+    }
+    sptr<OHOS::SurfaceBuffer> buffer = GetSurfaceBuffer(layer, bufferWidth, bufferHeight);
+    if (buffer == nullptr || buffer->GetVirAddr() == nullptr) {
+        return false;
+    }
+    auto addr = static_cast<uint8_t *>(buffer->GetVirAddr());
+    if (!DoDraw(addr, buffer->GetWidth(), buffer->GetHeight(), imagePath)) {
+        WLOGE("draw window pixel failed");
+        return false;
+    }
+    OHOS::BufferFlushConfig flushConfig = {
+        .damage = {
+            .w = buffer->GetWidth(),
+            .h = buffer->GetHeight(),
+        },
+    };
+    OHOS::SurfaceError ret = layer->FlushBuffer(buffer, -1, flushConfig);
+    if (ret != OHOS::SurfaceError::SURFACE_ERROR_OK) {
+        WLOGFE("draw pointer FlushBuffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return false;
+    }
+    return true;
+}
+
+bool DrawSurface::DrawColor(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+    uint32_t color)
+{
+    sptr<OHOS::Surface> layer = GetLayer(surfaceNode);
+    if (layer == nullptr) {
+        WLOGFE("layer is nullptr");
+        return false;
+    }
+    sptr<OHOS::SurfaceBuffer> buffer = GetSurfaceBuffer(layer, bufferWidth, bufferHeight);
+    if (buffer == nullptr || buffer->GetVirAddr() == nullptr) {
+        return false;
+    }
+    auto addr = static_cast<uint8_t *>(buffer->GetVirAddr());
+    if (!DoDraw(addr, buffer->GetWidth(), buffer->GetHeight(), color)) {
+        WLOGE("draw window color failed");
+        return false;
+    }
+    OHOS::BufferFlushConfig flushConfig = {
+        .damage = {
+            .w = buffer->GetWidth(),
+            .h = buffer->GetHeight(),
+        },
+    };
+    OHOS::SurfaceError ret = layer->FlushBuffer(buffer, -1, flushConfig);
+    if (ret != OHOS::SurfaceError::SURFACE_ERROR_OK) {
+        WLOGFE("draw pointer FlushBuffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return false;
+    }
+    return true;
+}
+
+sptr<OHOS::Surface> DrawSurface::GetLayer(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode)
+{
+    if (surfaceNode == nullptr) {
+        return nullptr;
+    }
+    return surfaceNode->GetSurface();
+}
+
+sptr<OHOS::SurfaceBuffer> DrawSurface::GetSurfaceBuffer(sptr<OHOS::Surface> layer,
+    int32_t bufferWidth, int32_t bufferHeight)
+{
+    sptr<OHOS::SurfaceBuffer> buffer;
+    int32_t releaseFence = 0;
+    OHOS::BufferRequestConfig config = {
+        .width = bufferWidth,
+        .height = bufferHeight,
+        .strideAlignment = 0x8,
+        .format = PIXEL_FMT_RGBA_8888,
+        .usage = HBM_USE_CPU_READ | HBM_USE_CPU_WRITE | HBM_USE_MEM_DMA,
+    };
+
+    OHOS::SurfaceError ret = layer->RequestBuffer(buffer, releaseFence, config);
+    if (ret != OHOS::SURFACE_ERROR_OK) {
+        WLOGFE("request buffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return nullptr;
+    }
+    return buffer;
+}
+
+std::unique_ptr<OHOS::Media::PixelMap> DrawSurface::DecodeImageToPixelMap(const std::string &imagePath)
+{
+    OHOS::Media::SourceOptions opts;
+    opts.formatHint = "image/png";
+    uint32_t ret = 0;
+    auto imageSource = OHOS::Media::ImageSource::CreateImageSource(imagePath, opts, ret);
+    // CHKPP(imageSource);
+    std::set<std::string> formats;
+    ret = imageSource->GetSupportedFormats(formats);
+    WLOGFD("get supported format ret:%{public}u", ret);
+
+    OHOS::Media::DecodeOptions decodeOpts;
+    std::unique_ptr<OHOS::Media::PixelMap> pixelMap = imageSource->CreatePixelMap(decodeOpts, ret);
+    if (pixelMap == nullptr) {
+        WLOGFE("pixelMap is nullptr");
+    }
+    return pixelMap;
+}
+
+void DrawSurface::DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas, const std::string& imagePath)
+{
+    std::unique_ptr<OHOS::Media::PixelMap> pixelmap = DecodeImageToPixelMap(imagePath);
+    if (pixelmap == nullptr) {
+        WLOGFE("drawing pixel map is nullptr");
+        return;
+    }
+    OHOS::Rosen::Drawing::Pen pen;
+    pen.SetAntiAlias(true);
+    pen.SetColor(OHOS::Rosen::Drawing::Color::COLOR_BLUE);
+    OHOS::Rosen::Drawing::scalar penWidth = 1;
+    pen.SetWidth(penWidth);
+    canvas.AttachPen(pen);
+    canvas.DrawBitmap(*pixelmap, 0, 0);
+}
+
+bool DrawSurface::DoDraw(uint8_t *addr, uint32_t width, uint32_t height, const std::string& imagePath)
+{
+    OHOS::Rosen::Drawing::Bitmap bitmap;
+    OHOS::Rosen::Drawing::BitmapFormat format { OHOS::Rosen::Drawing::COLORTYPE_RGBA_8888,
+        OHOS::Rosen::Drawing::ALPHATYPE_OPAQUYE };
+    bitmap.Build(width, height, format);
+    OHOS::Rosen::Drawing::Canvas canvas;
+    canvas.Bind(bitmap);
+    canvas.Clear(OHOS::Rosen::Drawing::Color::COLOR_TRANSPARENT);
+    DrawPixelmap(canvas, imagePath);
+    static constexpr uint32_t stride = 4;
+    uint32_t addrSize = width * height * stride;
+    errno_t ret = memcpy_s(addr, addrSize, bitmap.GetPixels(), addrSize);
+    if (ret != EOK) {
+        WLOGFE("draw failed");
+        return false;
+    }
+    return true;
+}
+bool DrawSurface::DoDraw(uint8_t *addr, uint32_t width, uint32_t height, uint32_t color)
+{
+    OHOS::Rosen::Drawing::Bitmap bitmap;
+    OHOS::Rosen::Drawing::BitmapFormat format { OHOS::Rosen::Drawing::COLORTYPE_RGBA_8888,
+        OHOS::Rosen::Drawing::ALPHATYPE_OPAQUYE };
+    bitmap.Build(width, height, format);
+    OHOS::Rosen::Drawing::Canvas canvas;
+    canvas.Bind(bitmap);
+    canvas.Clear(color);
+
+    static constexpr uint32_t stride = 4;
+    uint32_t addrSize = width * height * stride;
+    errno_t ret = memcpy_s(addr, addrSize, bitmap.GetPixels(), addrSize);
+    if (ret != EOK) {
+        WLOGFE("draw failed");
+        return false;
+    }
+    return true;
+}
+} // Rosen
+} // OHOS
\ No newline at end of file
diff --git a/utils/include/draw_surface.h b/utils/include/draw_surface.h
new file mode 100644
index 00000000..1dd19395
--- /dev/null
+++ b/utils/include/draw_surface.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2022-2022 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef DRAW_SURFACE_H
+#define DRAW_SURFACE_H
+
+#include "draw/canvas.h"
+#include "nocopyable.h"
+#include "pixel_map.h"
+#include "refbase.h"
+#include "ui/rs_surface_node.h"
+#include "wm_common.h"
+#include "window.h"
+
+namespace OHOS {
+namespace Rosen {
+class DrawSurface {
+public:
+    ~DrawSurface() = default;
+    static bool DrawColor(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth,
+        int32_t bufferHeight, uint32_t color);
+    static bool DrawImage(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth,
+        int32_t bufferHeight,const std::string& imagePath);
+private:
+    DrawSurface() {};
+    static bool DoDraw(uint8_t *addr, uint32_t width, uint32_t height, const std::string& imagePath);
+    static bool DoDraw(uint8_t *addr, uint32_t width, uint32_t height, uint32_t color);
+    static sptr<OHOS::Surface> GetLayer(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode);
+    static sptr<OHOS::SurfaceBuffer> GetSurfaceBuffer(sptr<OHOS::Surface> layer,
+        int32_t bufferWidth, int32_t bufferHeight);
+    static void DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas, const std::string& imagePath);
+    static std::unique_ptr<OHOS::Media::PixelMap> DecodeImageToPixelMap(const std::string &imagePath);
+};
+} // Rosen
+} // OHOS
+#endif  // DRAW_SURFACE_H
\ No newline at end of file
diff --git a/utils/include/surface_draw.h b/utils/include/surface_draw.h
index b312159f..8db73f64 100644
--- a/utils/include/surface_draw.h
+++ b/utils/include/surface_draw.h
@@ -23,6 +23,11 @@
 #endif
 #include "refbase.h"
 #include "wm_common.h"
+#include "window.h"
+
+#include "draw/canvas.h"
+#include "nocopyable.h"
+#include "pixel_map.h"
 
 namespace OHOS {
 namespace Rosen {
@@ -37,6 +42,19 @@ public:
     bool DecodeImageFile(const char* filename, SkBitmap& bitmap);
     void DrawSkImage(std::shared_ptr<RSSurfaceNode> surfaceNode, Rect winRect,
         sptr<Media::PixelMap> pixelMap, uint32_t bkgColor);
+
+    bool DrawWindow(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+        uint32_t color);
+    bool DrawWindow(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+        const std::string& imagePath);
+    bool DoDraw(uint8_t *addr, uint32_t width, uint32_t height, const std::string& imagePath);
+    bool DoDraw(uint8_t *addr, uint32_t width, uint32_t height, uint32_t color);
+    sptr<OHOS::Surface> GetLayer(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode);
+    sptr<OHOS::SurfaceBuffer> GetSurfaceBuffer(sptr<OHOS::Surface> layer,
+        int32_t bufferWidth, int32_t bufferHeight) const;
+
+    void DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas, const std::string& imagePath);
+    std::unique_ptr<OHOS::Media::PixelMap> DecodeImageToPixelMap(const std::string &imagePath);
 private:
 
     std::shared_ptr<RSSurface> PrepareDraw(std::shared_ptr<RSSurfaceNode> surfaceNode,
diff --git a/utils/src/surface_draw.cpp b/utils/src/surface_draw.cpp
index d4ebc775..70c0fa83 100644
--- a/utils/src/surface_draw.cpp
+++ b/utils/src/surface_draw.cpp
@@ -24,6 +24,12 @@
 #include "include/core/SkData.h"
 #include "include/core/SkImage.h"
 #include "include/core/SkPixmap.h"
+
+#include "image/bitmap.h"
+#include "image_source.h"
+#include "image_type.h"
+#include "image_utils.h"
+#include "pixel_map.h"
 namespace OHOS {
 namespace Rosen {
 namespace {
@@ -234,5 +240,169 @@ void SurfaceDraw::DrawSkImage(std::shared_ptr<RSSurfaceNode> surfaceNode, Rect w
     }
     return;
 }
+
+bool SurfaceDraw::DrawWindow(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+    const std::string& imagePath)
+{
+    sptr<OHOS::Surface> layer = GetLayer(surfaceNode);
+    if (layer == nullptr) {
+        WLOGFE("layer is nullptr");
+        return false;
+    }
+    sptr<OHOS::SurfaceBuffer> buffer = GetSurfaceBuffer(layer, bufferWidth, bufferHeight);
+    if (buffer == nullptr || buffer->GetVirAddr() == nullptr) {
+        return false;
+    }
+    auto addr = static_cast<uint8_t *>(buffer->GetVirAddr());
+    if (!DoDraw(addr, buffer->GetWidth(), buffer->GetHeight(), imagePath)) {
+        WLOGE("draw window pixel failed");
+        return false;
+    }
+    OHOS::BufferFlushConfig flushConfig = {
+        .damage = {
+            .w = buffer->GetWidth(),
+            .h = buffer->GetHeight(),
+        },
+    };
+    OHOS::SurfaceError ret = layer->FlushBuffer(buffer, -1, flushConfig);
+    if (ret != OHOS::SurfaceError::SURFACE_ERROR_OK) {
+        WLOGFE("draw pointer FlushBuffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return false;
+    }
+    return true;
+}
+
+bool SurfaceDraw::DrawWindow(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode, int32_t bufferWidth, int32_t bufferHeight,
+    uint32_t color)
+{
+    sptr<OHOS::Surface> layer = GetLayer(surfaceNode);
+    if (layer == nullptr) {
+        WLOGFE("layer is nullptr");
+        return false;
+    }
+    sptr<OHOS::SurfaceBuffer> buffer = GetSurfaceBuffer(layer, bufferWidth, bufferHeight);
+    if (buffer == nullptr || buffer->GetVirAddr() == nullptr) {
+        return false;
+    }
+    auto addr = static_cast<uint8_t *>(buffer->GetVirAddr());
+    if (!DoDraw(addr, buffer->GetWidth(), buffer->GetHeight(), color)) {
+        WLOGE("draw window color failed");
+        return false;
+    }
+    OHOS::BufferFlushConfig flushConfig = {
+        .damage = {
+            .w = buffer->GetWidth(),
+            .h = buffer->GetHeight(),
+        },
+    };
+    OHOS::SurfaceError ret = layer->FlushBuffer(buffer, -1, flushConfig);
+    if (ret != OHOS::SurfaceError::SURFACE_ERROR_OK) {
+        WLOGFE("draw pointer FlushBuffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return false;
+    }
+    return true;
+}
+
+sptr<OHOS::Surface> SurfaceDraw::GetLayer(std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode)
+{
+    if (surfaceNode == nullptr) {
+        return nullptr;
+    }
+    return surfaceNode->GetSurface();
+}
+
+sptr<OHOS::SurfaceBuffer> SurfaceDraw::GetSurfaceBuffer(sptr<OHOS::Surface> layer, int32_t bufferWidth,
+    int32_t bufferHeight) const
+{
+    sptr<OHOS::SurfaceBuffer> buffer;
+    int32_t releaseFence = 0;
+    OHOS::BufferRequestConfig config = {
+        .width = bufferWidth,
+        .height = bufferHeight,
+        .strideAlignment = 0x8,
+        .format = PIXEL_FMT_RGBA_8888,
+        .usage = HBM_USE_CPU_READ | HBM_USE_CPU_WRITE | HBM_USE_MEM_DMA,
+    };
+
+    OHOS::SurfaceError ret = layer->RequestBuffer(buffer, releaseFence, config);
+    if (ret != OHOS::SURFACE_ERROR_OK) {
+        WLOGFE("request buffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return nullptr;
+    }
+    return buffer;
+}
+
+std::unique_ptr<OHOS::Media::PixelMap> SurfaceDraw::DecodeImageToPixelMap(const std::string &imagePath)
+{
+    OHOS::Media::SourceOptions opts;
+    opts.formatHint = "image/png";
+    uint32_t ret = 0;
+    auto imageSource = OHOS::Media::ImageSource::CreateImageSource(imagePath, opts, ret);
+    // CHKPP(imageSource);
+    std::set<std::string> formats;
+    ret = imageSource->GetSupportedFormats(formats);
+    WLOGFD("get supported format ret:%{public}u", ret);
+
+    OHOS::Media::DecodeOptions decodeOpts;
+    std::unique_ptr<OHOS::Media::PixelMap> pixelMap = imageSource->CreatePixelMap(decodeOpts, ret);
+    if (pixelMap == nullptr) {
+        WLOGFE("pixelMap is nullptr");
+    }
+    return pixelMap;
+}
+
+void SurfaceDraw::DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas, const std::string& imagePath)
+{
+    std::unique_ptr<OHOS::Media::PixelMap> pixelmap = DecodeImageToPixelMap(imagePath);
+    if (pixelmap == nullptr) {
+        WLOGFE("drawing pixel map is nullptr");
+        return;
+    }
+    OHOS::Rosen::Drawing::Pen pen;
+    pen.SetAntiAlias(true);
+    pen.SetColor(OHOS::Rosen::Drawing::Color::COLOR_BLUE);
+    OHOS::Rosen::Drawing::scalar penWidth = 1;
+    pen.SetWidth(penWidth);
+    canvas.AttachPen(pen);
+    canvas.DrawBitmap(*pixelmap, 0, 0);
+}
+
+bool SurfaceDraw::DoDraw(uint8_t *addr, uint32_t width, uint32_t height, const std::string& imagePath)
+{
+    OHOS::Rosen::Drawing::Bitmap bitmap;
+    OHOS::Rosen::Drawing::BitmapFormat format { OHOS::Rosen::Drawing::COLORTYPE_RGBA_8888,
+        OHOS::Rosen::Drawing::ALPHATYPE_OPAQUYE };
+    bitmap.Build(width, height, format);
+    OHOS::Rosen::Drawing::Canvas canvas;
+    canvas.Bind(bitmap);
+    canvas.Clear(OHOS::Rosen::Drawing::Color::COLOR_TRANSPARENT);
+    DrawPixelmap(canvas, imagePath);
+    static constexpr uint32_t stride = 4;
+    uint32_t addrSize = width * height * stride;
+    errno_t ret = memcpy_s(addr, addrSize, bitmap.GetPixels(), addrSize);
+    if (ret != EOK) {
+        WLOGFE("draw failed");
+        return false;
+    }
+    return true;
+}
+bool SurfaceDraw::DoDraw(uint8_t *addr, uint32_t width, uint32_t height, uint32_t color)
+{
+    OHOS::Rosen::Drawing::Bitmap bitmap;
+    OHOS::Rosen::Drawing::BitmapFormat format { OHOS::Rosen::Drawing::COLORTYPE_RGBA_8888,
+        OHOS::Rosen::Drawing::ALPHATYPE_OPAQUYE };
+    bitmap.Build(width, height, format);
+    OHOS::Rosen::Drawing::Canvas canvas;
+    canvas.Bind(bitmap);
+    canvas.Clear(color);
+    static constexpr uint32_t stride = 4;
+    uint32_t addrSize = width * height * stride;
+    errno_t ret = memcpy_s(addr, addrSize, bitmap.GetPixels(), addrSize);
+    if (ret != EOK) {
+        WLOGFE("draw failed");
+        return false;
+    }
+    return true;
+}
 } // Rosen
 } // OHOS
\ No newline at end of file
diff --git a/wm/src/window_impl.cpp b/wm/src/window_impl.cpp
index 0dcecf56..03d40f2f 100644
--- a/wm/src/window_impl.cpp
+++ b/wm/src/window_impl.cpp
@@ -2305,6 +2305,10 @@ void WindowImpl::SetDefaultOption()
             property_->SetFocusable(false);
             break;
         }
+        case WindowType::WINDOW_TYPE_PLACE_HOLDER: {
+            AddWindowFlag(WindowFlag::WINDOW_FLAG_FORBID_SPLIT_MOVE);
+            break;
+        }
         default:
             break;
     }
diff --git a/wmserver/BUILD.gn b/wmserver/BUILD.gn
index 6637bc4c..e76a11db 100644
--- a/wmserver/BUILD.gn
+++ b/wmserver/BUILD.gn
@@ -73,6 +73,7 @@ ohos_shared_library("libwms") {
 
   deps = [
     "//foundation/arkui/ace_engine/interfaces/inner_api/ui_service_manager:ui_service_mgr",
+    "//foundation/graphic/graphic_2d/rosen/modules/2d_graphics:2d_graphics",
     "//foundation/graphic/graphic_2d/rosen/modules/render_service_client:librender_service_client",
     "//foundation/windowmanager/dm:libdm",
     "//foundation/windowmanager/dmserver:libdms",
diff --git a/wmserver/include/window_inner_manager.h b/wmserver/include/window_inner_manager.h
index 3ab54045..b8a40e95 100644
--- a/wmserver/include/window_inner_manager.h
+++ b/wmserver/include/window_inner_manager.h
@@ -20,12 +20,35 @@
 #include "event_handler.h"
 #include "event_runner.h"
 
+#include <ui/rs_surface_node.h>
+#include "draw/canvas.h"
+#include "nocopyable.h"
+#include "pixel_map.h"
+
 #include "wm_common.h"
 #include "wm_single_instance.h"
+#include "window.h"
 
 namespace OHOS {
 namespace Rosen {
+class TouchOutsideListener : public ITouchOutsideListener {
+    virtual void OnTouchOutside();
+};
+class InputListener : public IInputEventListener {
+    virtual void OnKeyEvent(std::shared_ptr<MMI::KeyEvent>& keyEvent);
+    virtual void OnPointerInputEvent(std::shared_ptr<MMI::PointerEvent>& pointerEvent);
+};
+class LifeCycle : public IWindowLifeCycle {
+    virtual void AfterForeground() {};
+    virtual void AfterBackground() {};
+    virtual void AfterFocused() {};
+    virtual void AfterInactive();
+    virtual void AfterUnfocused() {};
+};
 class WindowInnerManager : public RefBase {
+friend class TouchOutsideListener;
+friend class InputListener;
+friend class LifeCycle;
 WM_DECLARE_SINGLE_INSTANCE_BASE(WindowInnerManager);
 using EventRunner = OHOS::AppExecFwk::EventRunner;
 using EventHandler = OHOS::AppExecFwk::EventHandler;
@@ -34,6 +57,8 @@ public:
     void Stop();
     void CreateWindow(std::string name, WindowType type, Rect rect);
     void DestroyWindow();
+    void CreatePlaceHolderWindow(WindowMode mode, DisplayId displayId);
+    void DestroyPlaceHolderWindow();
 public:
     enum class InnerWMRunningState {
         STATE_NOT_START,
@@ -45,8 +70,15 @@ private:
     WindowInnerManager();
     bool Init();
     void HandleCreateWindow(std::string name, WindowType type, Rect rect);
+    void HandleCreatePlaceHolderWindow(WindowMode mode, DisplayId displayId);
     void HandleDestroyWindow();
 
+    sptr<OHOS::Surface> GetLayer();
+    sptr<OHOS::SurfaceBuffer> GetSurfaceBuffer(sptr<OHOS::Surface> layer) const;
+    void DoDraw(uint8_t *addr, uint32_t width, uint32_t height);
+    void DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas);
+    std::unique_ptr<OHOS::Media::PixelMap> DecodeImageToPixelMap(const std::string &imagePath);
+
 private:
     int32_t dialogId_ = -1;
     std::shared_ptr<EventHandler> eventHandler_;
@@ -54,6 +86,7 @@ private:
     InnerWMRunningState state_;
     std::string dividerParams_ = "";
     const std::string INNER_WM_THREAD_NAME = "inner_window_manager";
+    sptr<OHOS::Rosen::Window> placeHolderwindow_ = nullptr;
 };
 } // namespace Rosen
 } // namespace OHOS
diff --git a/wmserver/include/window_pair.h b/wmserver/include/window_pair.h
index 86d8391c..237cdc4a 100644
--- a/wmserver/include/window_pair.h
+++ b/wmserver/include/window_pair.h
@@ -250,6 +250,7 @@ private:
     sptr<WindowNode> primary_;
     sptr<WindowNode> secondary_;
     sptr<WindowNode> divider_;
+    // sptr<WindowNode> placeholder_;
     WindowPairStatus status_ = {WindowPairStatus::STATUS_EMPTY};
     DisplayGroupWindowTree& displayGroupWindowTree_;
     bool isAllAppWindowsRestoring_ { false };
diff --git a/wmserver/include/window_zorder_policy.h b/wmserver/include/window_zorder_policy.h
index 8df41594..4f52082f 100644
--- a/wmserver/include/window_zorder_policy.h
+++ b/wmserver/include/window_zorder_policy.h
@@ -45,6 +45,7 @@ private:
         { WindowType::WINDOW_TYPE_APP_COMPONENT,        2 },
         { WindowType::WINDOW_TYPE_APP_LAUNCHING,        101 },
         { WindowType::WINDOW_TYPE_DOCK_SLICE,           0 },
+        { WindowType::WINDOW_TYPE_PLACE_HOLDER,         0 },
         { WindowType::WINDOW_TYPE_LAUNCHER_RECENT,      102 },
         { WindowType::WINDOW_TYPE_LAUNCHER_DOCK,        103 },
         { WindowType::WINDOW_TYPE_INCOMING_CALL,        104 },
diff --git a/wmserver/src/window_inner_manager.cpp b/wmserver/src/window_inner_manager.cpp
index 5cddc9f0..c4e35708 100644
--- a/wmserver/src/window_inner_manager.cpp
+++ b/wmserver/src/window_inner_manager.cpp
@@ -15,14 +15,22 @@
 
 #include "window_inner_manager.h"
 
+#include "draw_surface.h"
 #include "ui_service_mgr_client.h"
 #include "window_manager_hilog.h"
-#include "window.h"
+#include "image/bitmap.h"
+#include "image_source.h"
+#include "image_type.h"
+#include "image_utils.h"
+#include "pixel_map.h"
 
 namespace OHOS {
 namespace Rosen {
 namespace {
     constexpr HiviewDFX::HiLogLabel LABEL = {LOG_CORE, HILOG_DOMAIN_WINDOW, "WindowInnerManager"};
+    const std::string IMAGE_PLACE_HOLDER_PNG_PATH = "/etc/window/resources/bg_place_holder.png";
+    const int32_t IMAGE_WIDTH = 512;
+    const int32_t IMAGE_HEIGHT = 512;
 }
 WM_IMPLEMENT_SINGLE_INSTANCE(WindowInnerManager)
 
@@ -90,6 +98,179 @@ void WindowInnerManager::HandleCreateWindow(std::string name, WindowType type, R
     return;
 }
 
+std::unique_ptr<OHOS::Media::PixelMap> WindowInnerManager::DecodeImageToPixelMap(const std::string &imagePath)
+{
+    OHOS::Media::SourceOptions opts;
+    opts.formatHint = "image/png";
+    uint32_t ret = 0;
+    auto imageSource = OHOS::Media::ImageSource::CreateImageSource(imagePath, opts, ret);
+    // CHKPP(imageSource);
+    std::set<std::string> formats;
+    ret = imageSource->GetSupportedFormats(formats);
+    WLOGFD("get supported format ret:%{public}u", ret);
+
+    OHOS::Media::DecodeOptions decodeOpts;
+    std::unique_ptr<OHOS::Media::PixelMap> pixelMap = imageSource->CreatePixelMap(decodeOpts, ret);
+    if (pixelMap == nullptr) {
+        WLOGFE("pixelMap is nullptr");
+    }
+    return pixelMap;
+}
+
+void WindowInnerManager::DrawPixelmap(OHOS::Rosen::Drawing::Canvas &canvas)
+{
+    std::unique_ptr<OHOS::Media::PixelMap> pixelmap = DecodeImageToPixelMap(IMAGE_PLACE_HOLDER_PNG_PATH);
+    OHOS::Rosen::Drawing::Pen pen;
+    pen.SetAntiAlias(true);
+    pen.SetColor(OHOS::Rosen::Drawing::Color::COLOR_BLUE);
+    OHOS::Rosen::Drawing::scalar penWidth = 1;
+    pen.SetWidth(penWidth);
+    canvas.AttachPen(pen);
+    canvas.DrawBitmap(*pixelmap, 0, 0);
+}
+
+void WindowInnerManager::DoDraw(uint8_t *addr, uint32_t width, uint32_t height)
+{
+    OHOS::Rosen::Drawing::Bitmap bitmap;
+    OHOS::Rosen::Drawing::BitmapFormat format { OHOS::Rosen::Drawing::COLORTYPE_RGBA_8888,
+        OHOS::Rosen::Drawing::ALPHATYPE_OPAQUYE };
+    bitmap.Build(width, height, format);
+    OHOS::Rosen::Drawing::Canvas canvas;
+    canvas.Bind(bitmap);
+    canvas.Clear(OHOS::Rosen::Drawing::Color::COLOR_TRANSPARENT);
+    DrawPixelmap(canvas);
+    static constexpr uint32_t stride = 4;
+    uint32_t addrSize = width * height * stride;
+    errno_t ret = memcpy_s(addr, addrSize, bitmap.GetPixels(), addrSize);
+    if (ret != EOK) {
+        return;
+    }
+}
+void WindowInnerManager::DestroyPlaceHolderWindow()
+{
+    if (placeHolderwindow_ != nullptr) {
+        placeHolderwindow_->Destroy();
+        placeHolderwindow_ = nullptr;
+    }
+}
+
+void WindowInnerManager::CreatePlaceHolderWindow(WindowMode mode, DisplayId displayId)
+{
+    eventHandler_->PostTask([this, mode, displayId]() {
+        HandleCreatePlaceHolderWindow(mode, displayId);
+    });
+    return;
+}
+
+void TouchOutsideListener::OnTouchOutside()
+{
+    WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+}
+
+void InputListener::OnKeyEvent(std::shared_ptr<MMI::KeyEvent>& keyEvent)
+{
+    WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+}
+
+void InputListener::OnPointerInputEvent(std::shared_ptr<MMI::PointerEvent>& pointerEvent)
+{
+    WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+}
+
+void LifeCycle::AfterInactive()
+{
+    WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+}
+
+void WindowInnerManager::HandleCreatePlaceHolderWindow(WindowMode mode, DisplayId displayId)
+{
+    if (placeHolderwindow_ != nullptr) {
+        return;
+    }
+    sptr<WindowOption> opt = new (std::nothrow) WindowOption();
+    if (opt == nullptr) {
+        WLOGFE("Window option is nullptr.");
+        return;
+    }
+    opt->SetWindowType(WindowType::WINDOW_TYPE_PLACE_HOLDER);
+    opt->SetFocusable(false);
+    opt->SetWindowMode(mode);
+    placeHolderwindow_ = Window::Create("place_holder" + std::to_string(displayId), opt);
+    if (placeHolderwindow_ == nullptr) {
+        WLOGFE("Window is nullptr.");
+        return;
+    }
+    sptr<ITouchOutsideListener> touchOutsideListener = new TouchOutsideListener();
+    // sptr<IInputEventListener> inputListener = new InputListener();
+    sptr<IWindowLifeCycle> lifeCycleListener = new LifeCycle();
+    placeHolderwindow_->RegisterTouchOutsideListener(touchOutsideListener);
+    // placeHolderwindow_->RegisterInputEventListener(inputListener);
+    placeHolderwindow_->RegisterLifeCycleListener(lifeCycleListener);
+    // placeHolderwindow_->Show();
+    if (!OHOS::Rosen::DrawSurface::DrawImage(placeHolderwindow_->GetSurfaceNode(),
+        IMAGE_WIDTH, IMAGE_HEIGHT, IMAGE_PLACE_HOLDER_PNG_PATH)) {
+            WLOGE("draw surface failed");
+            return;
+    }
+    // sptr<OHOS::Surface> layer = GetLayer();
+    // if (layer == nullptr) {
+    //     placeHolderwindow_->Destroy();
+    //     placeHolderwindow_ = nullptr;
+    //     return;
+    // }
+
+    // sptr<OHOS::SurfaceBuffer> buffer = GetSurfaceBuffer(layer);
+    // if (buffer == nullptr || buffer->GetVirAddr() == nullptr) {
+    //     placeHolderwindow_->Destroy();
+    //     placeHolderwindow_ = nullptr;
+    //     return;
+    // }
+
+    // auto addr = static_cast<uint8_t *>(buffer->GetVirAddr());
+    // DoDraw(addr, buffer->GetWidth(), buffer->GetHeight());
+    // OHOS::BufferFlushConfig flushConfig = {
+    //     .damage = {
+    //         .w = buffer->GetWidth(),
+    //         .h = buffer->GetHeight(),
+    //     },
+    // };
+    // OHOS::SurfaceError ret = layer->FlushBuffer(buffer, -1, flushConfig);
+    // WLOGFD("draw pointer FlushBuffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+    placeHolderwindow_->Show();
+    return;
+}
+
+sptr<OHOS::Surface> WindowInnerManager::GetLayer()
+{
+    std::shared_ptr<OHOS::Rosen::RSSurfaceNode> surfaceNode = placeHolderwindow_->GetSurfaceNode();
+    if (surfaceNode == nullptr) {
+        placeHolderwindow_->Destroy();
+        placeHolderwindow_ = nullptr;
+        return nullptr;
+    }
+    return surfaceNode->GetSurface();
+}
+
+sptr<OHOS::SurfaceBuffer> WindowInnerManager::GetSurfaceBuffer(sptr<OHOS::Surface> layer) const
+{
+    sptr<OHOS::SurfaceBuffer> buffer;
+    int32_t releaseFence = 0;
+    OHOS::BufferRequestConfig config = {
+        .width = IMAGE_WIDTH,
+        .height = IMAGE_HEIGHT,
+        .strideAlignment = 0x8,
+        .format = PIXEL_FMT_RGBA_8888,
+        .usage = HBM_USE_CPU_READ | HBM_USE_CPU_WRITE | HBM_USE_MEM_DMA,
+    };
+
+    OHOS::SurfaceError ret = layer->RequestBuffer(buffer, releaseFence, config);
+    if (ret != OHOS::SURFACE_ERROR_OK) {
+        WLOGFE("request buffer ret:%{public}s", SurfaceErrorStr(ret).c_str());
+        return nullptr;
+    }
+    return buffer;
+}
+
 void WindowInnerManager::HandleDestroyWindow()
 {
     if (dialogId_ == -1) {
diff --git a/wmserver/src/window_pair.cpp b/wmserver/src/window_pair.cpp
index 095b4add..3b018ba3 100644
--- a/wmserver/src/window_pair.cpp
+++ b/wmserver/src/window_pair.cpp
@@ -327,15 +327,21 @@ void WindowPair::UpdateIfSplitRelated(sptr<WindowNode>& node)
         WLOGI("Window id: %{public}u is not split related and paired.", node->GetWindowId());
         return;
     }
+    if ((node->GetWindowType() == WindowType::WINDOW_TYPE_PLACE_HOLDER) &&
+        ((primary_ != nullptr && primary_->GetWindowMode() == node->GetWindowMode()) ||
+        (secondary_ != nullptr && secondary_->GetWindowMode() == node->GetWindowMode()))) {
+        WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+        return;
+    }
     WLOGI("Current status: %{public}u, window id: %{public}u mode: %{public}u",
         status_, node->GetWindowId(), node->GetWindowMode());
     if (status_ == WindowPairStatus::STATUS_EMPTY) {
         Insert(node);
         if (!isAllAppWindowsRestoring_) {
             // find pairable window from trees or send broadcast
-            sptr<WindowNode> pairableNode = GetPairableWindow(node);
-            // insert pairable node
-            Insert(pairableNode);
+            WindowMode holderMode = node->GetWindowMode() == WindowMode::WINDOW_MODE_SPLIT_PRIMARY ?
+                WindowMode::WINDOW_MODE_SPLIT_SECONDARY : WindowMode::WINDOW_MODE_SPLIT_PRIMARY;
+            WindowInnerManager::GetInstance().CreatePlaceHolderWindow(holderMode, displayId_);
         }
     } else {
         if (Find(node) == nullptr) {
@@ -432,6 +438,10 @@ void WindowPair::Insert(sptr<WindowNode>& node)
     if (node == nullptr) {
         return;
     }
+    // if (node->GetWindowType() == WindowType::WINDOW_TYPE_PLACE_HOLDER) {
+    //     placeholder_ = node;
+    //     return;
+    // }
     WLOGI("Insert a window to pair id: %{public}u", node->GetWindowId());
     sptr<WindowNode> pairedNode;
     if (node->GetWindowMode() == WindowMode::WINDOW_MODE_SPLIT_PRIMARY) {
@@ -448,6 +458,10 @@ void WindowPair::Insert(sptr<WindowNode>& node)
     if (pairedNode != nullptr && pairedNode->abilityToken_ != nullptr) {
         MinimizeApp::AddNeedMinimizeApp(pairedNode, MinimizeReason::SPLIT_REPLACE);
     }
+    // if (placeholder_ != nullptr) {
+    //     WindowInnerManager::GetInstance().DestroyPlaceHolderWindow();
+    //     placeholder_ = nullptr;
+    // }
     UpdateWindowPairStatus();
 }
 
-- 
2.25.1

